- title: 集市與知識經濟學
  key: main
  id: 9
  order: 1
  link: economics-of-knowledge
  author: Ohad Asor
  date: May 01, 2020
  content: 在我們當前的世界中，很少有人可以直接將其知識貨幣化。我們幾乎從不買賣任何知識...
  main_content: <p>在我們當前的世界中，很少有人可以直接將其知識貨幣化。我們幾乎從不買賣任何知識。在經濟的環境中尋求知識通常是通過吸引那些我們認為可能涉及感興趣知識的領域的人們來完成的，就像沒有一個單獨的書回答每個問題，但是我們在涉及明顯領域的書籍。知識是我們經濟的重要組成部分，在這裡我們尋求能夠使知識經濟學更有效，更先進的案例。</p>
                <p>以機器可訪問的格式來形式化知識相對於書籍和搜索引擎而言具有一個優勢：數據不再是比特流，而是比特背後的含義，因此我們確實可以對小的知識片段進行自動語義查找在大量的寫作中。我們多次談論了共享知識庫如何在Tau及其基於邏輯的討論中發展。在一個不斷地形式化知識並在用戶之間共享知識的框架中，考慮一種經濟的基礎設施來促進形式知識經濟學的各個方面都是很自然的。在這篇文章中，我們將重點關注Agoras中知識經濟學的某些方面，而另一些方面則留待以後的寫作。現在是時候談論Agoras了，因為我們現在開始與Tau的持續開發同時進行開發。</p>
                <p>首先，讓我們考慮一下知識是如何產生或&ldquo;挖掘&rdquo;的。如果我們將知識視為超出[自然或人工]感官輸入的事物，則可以辯稱推理是從現有知識中產生新知識的行為。這樣的過程也可以自動完成。但是，我們如何指導這種自動搜索過程，使其產生有趣的結果？<br>
                  在過去，我們談到了&ldquo;有趣的問題&rdquo;的概念。就像答案是否正確一樣，問題是否有趣也同樣，但正確與否無關緊要，對問題沒有定義。我們認為，這定義了人類和機器在我們的環境中的作用：機器永遠無法分辨出哪個問題很有趣，因為這純粹是人類自然的依賴。機器的作用是通過自動完成已經投入到其中的知識的推理工作來幫助我們回答有趣的問題。</p>
                <p>可能需要在此處添加有關術語的說明：通過&ldquo;查詢&rdquo;，我們指的是我們要詢問機器的問題，並且我們希望機器在其知識庫中有足夠的數據以回答此查詢，而通過&ldquo;問題&rdquo;假設答案在系統中尚不明確，我們將其標記為&ldquo;有趣&rdquo;。另外，對於有關Tau的問題和答案的更詳細的討論，請參閱文章<a href="https://translate.google.com/translate?hl=es&prev=_t&sl=en&tl=zh-TW&u=http://www.idni.org/blog/art-of-self-ref">參考自我的</a>後半部分。</p>
                <p>簡而言之，問題和答案將在有關Tau的討論和知識形式化中發揮重要作用，但這也有助於理解知識的經濟學。如果知識很有趣，那麼一條知識就是有價值的，知識的價值應取決於興趣水平和回答問題的難度。機器很難回答答案，因為機器可以計算步數，此外，還有關於各種推理任務的複雜性的豐富理論（稱為描述性複雜性理論）。</p>
                <p>關注知識經濟學，問題和答案可能分別被視為需求和供應，儘管這並不能涵蓋全部情況，我們稍後將添加更多詳細信息。平台上的用戶將能夠以我們一貫提出的便捷，協作和自然的方式將問題標記為有趣的問題：通過討論。</p>
                <p>現在，讓我們想像一個知識淵博的人如何通過Agoras產生收入。從廣義上講，對某些問題感興趣的用戶可以為答案提供獎勵。答案的驗證可以通過幾種方式完成。在某些情況下，如常見的數學問題一樣，答題者可以提供答案的證明，並且就答案是否正確沒有爭議。再次使用描述性複雜性理論的考慮，我們甚至可能擁有有關這種驗證過程是否有望高效的信息，並且從密碼學的角度來看，還有很多要補充的內容，但這超出了我們的範圍。當前文章。</p>
                <p>但是，有時要求數學證明太多了。有時，人們可能會以傳統方式信任專家，只需通過常見的印像或推薦或廣告等方式，然後自動信任他們的答案。一個簡單的例子是信任一些您已經很熟悉的醫生，而不是要求他們為他們提供的每一項醫學建議提供數學證明，因為這會使整個事情變得不切實際（至少要等到唯一性之後）來）。</p>
                <p>因此，最後一個例子產生了一種形式的知識交易，該知識交易在上一篇文章中已經提到：考慮一些信譽良好的機構，例如大學或受信任的專家，這需要艱鉅的任務來規範一些龐大而有用的知識體系。然後，他們可以向用戶提供訂閱，以自動參與他們的討論。正如我們過去解釋的那樣，Tau將允許&ldquo;自動評論&rdquo;，以便它可以在您隨時間，通過發布或通過同意/不同意告訴您自己的意見（我們稱為&ldquo;世界觀&rdquo;）時自動代表您參加討論。和其他人。因此，該訂閱使訂閱者可以自動參與討論，討論中的數據來自受信任的來源（從單個用戶的角度來看）。在特定情況下，律師事務所提供其知識庫以自動參與公司討論，並可能自動評論某些想法合法或非法。</p>
                <p>訂閱的另一種形式是按查詢付費，允許訂閱者在不透露整個知識庫的情況下提出問題並獲得答案。此外，得益於Tau協作知識的形成，一個小組可以將知識形式化並一起貨幣化。</p>
                <p>在這一點上，值得一提的是Agoras最初的主要創新之一：&ldquo;自動商人&rdquo;的概念。用戶擁有自己的本地資產，即計算資源，知識，硬幣以及可能允許其正式世界觀考慮在內的其他資產。然後，Agoras將能夠通過查看提供的可用知識和合同，或者通過發布對某些知識或合同的競標來量身定制交易，所有這些都來自於將資產和機會組合成一筆好交易的連貫且經邏輯證明的計劃。甚至可以達到一種常見的自動計劃程序所無法聞到的程度：一旦在系統上正式製定法律，用戶就可以向Agoras提出不違反法律法規的交易。這只是邏輯推理機可以在經濟中發揮作用的一個小例子。</p>
                <p>回想一下，Agoras還將包含一個計算資源市場和一個未來的合同市場，如先前的帖子中所述。因此，&ldquo;自動商人&rdquo;是一個&ldquo;整體&rdquo;應用程序，可能涉及Tau和Agoras功能的所有部分。<a href="https://translate.google.com/translate?hl=es&prev=_t&sl=en&tl=zh-TW&u=http://www.idni.org/blog/agoras-to-tml">從Agoras到TML</a>的帖子中給出了另一個這樣的例子，概述了去中心化搜索引擎是一種相當複雜的知識經濟形式。</p>
                <p>我們對此設計有一些新的想法和計劃。所有人都強調，很明顯，人的接觸對於許多形式的知識轉移至關重要，並且並非所有知識都可能或適合在所有情況下形式化。通過交流形式化的知識來尋求醫生的快速建議並不總是首選的方式，私人補習也是如此，還有更多的例子。因此，我們打算基於<a href="https://translate.google.com/translate?hl=es&prev=_t&sl=en&tl=zh-TW&u=http://github.com/naturalog/bitagoras">此鏈接上</a>出現的非常古老的設計，以文本，音頻和視頻的形式提供自由形式的交易知識。請花一點時間閱讀它。大鎖定讓我們決定確實立即開始進行基於小額支付的視頻通話。</p>
                <p>關於這項計劃的新增內容，還有很多話要說，在即將發布的每月視頻更新中，我們將重點介紹更多和無關的非常好消息。</p>


- title: 共識和選擇
  key: main
  id: 8
  order: 2
  link: consensus-and-options
  author: Ohad Asor
  date: Mon 23, 2019
  content: 在本博文中，我們不會像在前三個博文中那樣對Tau和Agoras進行概述，但我們將深入探討每個方面的兩個特定部分&#58;Tau的治理模型和Agoras衍生品市場。
  main_content: <p  >在本博文中，我們不會像在前三個博文中那樣對Tau和Agoras進行概述，但我們將深入探討每個方面的兩個特定部分&#58;Tau的治理模型和Agoras衍生品市場。</p>
                <p  >正如上一篇文章中所承諾的那樣，在本篇文章中，我們將討論誰來決定。回想一下，Tau是由其用戶有效地決定的軟件，僅此而已。為此，用戶將不得不進行大規模的有效討論（Alpha和語言互聯網），闡明下一步Tau的代碼需要做什麼，然後將共識轉換為代碼（Beta），然後進行更新所有擁有最新代碼的客戶。但是應該使用哪種共識？全體一致，多數還是其他？</p>
                <p  >分散網絡軟件中多數表決的主要技術問題是無法檢測到同一個人的多個表決。如果我們通過要求對某些人給予一定程度的信任和投票權來軟化權力下放的要求，則可以避免這種情況。在完全分散和完全集中之間的某個中間位置的協議的一個示例是DPOS（委託權益證明），或者甚至純粹是通過抵押來實現的。在分散的環境中，一致意見也是一個問題，因為參與者可能會誠實或不誠實地阻止整個網絡達成共識。</p>
                <p  >一條經驗法則是不限制用戶做任何不影響其他用戶的事情。如果某組人希望系統以某種方式運行，而另一組人希望系統以不同的方式運行，那麼我們可以檢查兩組的偏好是否共存並且每個人對產品的看法是否不同。由於我們使用的語言具有可判定性，因此我們將能夠檢測到這一點。但是，確實不可能總是使這兩個更改共存，因為它們可能在系統的基礎上包含一些矛盾，這將使系統在組之間不兼容。</p>
                <p  >解決這種情況的一種方法是，組之間無法兼容共存的分歧是，要求組計算其提案（挖掘）的哈希值，直到哈希值足夠小為止。這就是比特幣的機制：就挖掘投資於其中的計算能力而言，更長的鍊是網絡首選的鏈。許多類似的基於區塊鏈的算法都是可能的，每種算法都有其自身的優缺點。可能有或沒有第一個的另一種方式是賦予某些用戶對此案進行投票的權力。這削弱了權力下放的要求，其好處是可以解決原本無法解決的衝突。</p>
                <p  >可以有許多其他方式，但都不是完美的。因此，它需要用戶之間進行討論，提出要約及其優缺點，並由此開始以社區支持的一組規則開始。這將通過集中的Alpha和Beta完成。 Alpha和Beta的用戶將決定最初的Tau的樣子，以及如何解決讓每個小組運行其客戶端代碼無法解決的矛盾的情況，以防使客戶端不兼容。</p>
                <p  >現在讓我們談談我們經常提到但從未真正解釋過的Agoras的一個方面。 Agoras將提供一個創新的衍生品市場，還具有獲得無風險存款利息的能力，而無需發行任何新硬幣，換句話說，無需通脹。</p>
                <p  >要逐步進行，讓我們首先了解衍生品市場的樣子。首先考慮一個人們僅在彼此之間出售資產的市場。然後，分類帳將為&ldquo;從資產A出售N個單位並以價格P購買資產B&rdquo;形式的買賣訂單。對於衍生產品市場，它非常相似：分類帳上的一條線可能看起來像是&ldquo;如果A / B對的市場價格從現在開始的一個月內低於（或高於）閾值T，那麼那時賣出N個資產A，並以價格P購買資產B。為您簽訂此合同，我將向您支付R硬幣的權利金&rdquo;。為了使該交易能夠完成，必須有其他人進行相反的交易：&ldquo;如果從現在起一個月內，A / B對的市場價格低於（或高於）閾值T，那麼到那時，我將購買資產A的N個單位並以價格P出售資產B，為此，我需要溢價-R&rdquo;。請注意，R可以是正數或負數，在這種情況下，聲明此合同的一方需要付款才能加入合同。</p>
                <p  >舉個例子，假設BTC / USD的價格為10,000美元，並考慮該合約&ldquo;如果從現在起的2個月內，BTC / USD的價格至少為11,000美元，那麼我將以10,000美元的價格從您那裡購買1個BTC，為使您簽訂這份合同，我將向您支付$ 800&rdquo;。因此，如果BTC / USD價格為11,000美元，則該合約的對等方將立即獲得800美元並有義務支付1000美元；如果BTC / USD價格更高，則有更高的金額。為此，他們必須鎖定抵押品（日常衍生品市場中的&ldquo;保證金&rdquo;）。這種合同稱為期權。請注意，結算貨幣可以是任何貨幣：我們不需要買方實際以10,000美元的價格購買1個BTC，然後以11,000美元的價格出售，並獲得1,000美元的利潤。可以用任何等值的$ 1,000來完成此結算。因此，在派生理論術語中，我們考慮美國選擇而不是歐洲選擇。</p>
                <p  >一個直接的困難是如何對溢價進行定價（示例中為800美元）。為此，有一個稱為諾貝爾獎的標準公式，稱為布萊克和斯科爾斯模型。在現實生活中，人們簽訂合同需要或給出的實際溢價價格通常與理論價格（Black＆Scholes）不同，具體取決於市場參與者對未來的預測。</p>
                <p  >布萊克和斯科爾斯（Black and Scholes）模型不僅提供定價選項，還提供重要的信息。它可以告訴您期權價格對標的資產（Delta）價值變化的敏感性，以及幾個更重要的指標，稱為&ldquo;<a href="https://en.wikipedia.org/wiki/Greeks_(finance)">希臘人</a>&rdquo;。布萊克和斯科爾斯向前邁進了一步，發現某些期權組合可以產生無風險的利息。這是無風險的，因為期權差額的總和為零，比照。零增量投資組合。這也會產生利息，因為在期權價格中考慮了貨幣的時間價值：提前2個月的期權的價格應高於提前1個月的期權的價格，因為不確定性更大，並且由於由於必須鎖定抵押品而導致的機會成本。</p>
                <p  >衍生品市場的用途通常有兩種：對沖和投機。世界上常見的衍生品市場受到 <a href="https://en.wikipedia.org/wiki/Leverage_(finance)">槓桿作用</a>，而槓桿作用只是藉貸的一個長期術語，允許極具風險的投機行為，並且被廣泛批評（在衍生工具範圍內）危害世界經濟。因此，Agoras的衍生產品市場將不支持任何形式的槓桿。套期保值是對期權的更真正的需求，這就是為什麼首先發明它們的原因。假設我們有一家歐洲公司的客戶向美國出口，因此該公司獲得了歐元，因此持有美元的客戶必須將美元轉換為歐元。如果歐元/美元比率上升，則客戶可能遭受損失。為了避免這種情況，客戶可以通過在衍生品市場上購買期權進行對沖。客戶將支付溢價，但會減少貨幣波動的風險。該期權的交易對手可能是某公司的客戶以美元付款，但該客戶持有歐元。為了提供與加密貨幣相關的對沖需求，假設有人購買了很多比特幣挖礦硬件並以美元支付。以比特幣計價的採礦收入多少已為人所知，但如果BTC / USD價格下跌，則採礦計劃可能會蒙受損失。因此，他們可能想購買期權並降低風險。</p>
                <p  >回到沒有通貨膨脹的Agoras無風險利息的問題的答案&ldquo;那麼，如果不是新印製的，利息錢從哪裡來呢？&rdquo;可能來自經濟參與者的對沖需求。請注意，這不是套利，並且確實，Black＆Scholes假定市場沒有套利機會。零增量投資組合的收入將反映貨幣的時間價值，換句話說，就是鎖定抵押品的獎勵。</p>
                <p  >我們展示了一個有條件的未來買/賣定單的示例，但條件可能比示例中的複雜得多。此外，他們還可以隱含給定，例如在TERM希臘人S：&ldquo;我想這合同會給我三角洲d和θ的T任意組合，我會支付溢價P代表的是&ldquo;。計算此類合同的理論價格P，並在訂單簿上進一步找到可產生給定條件的組合，這在計算上並不是一件容易的事。但這至少是一個令人滿意的近似值，我們將在Agoras中實現。通過僅指定投資組合的要求，這將允許下一代投資組合管理，而無需手動將其分解為要持有的衍生工具。</p>
                <p  >值得一提的最後一件事是這種衍生市場去中心化的能力。如果在同一鏈上編碼了多個硬幣，那麼應該可以在該鏈上也編碼買賣/衍生產品訂單。但這不能支持BTC / USD，因為我們沒有最新匯率的鏈上報價。為了使這種衍生市場能夠在具有不同區塊鏈的加密貨幣上運行，或者甚至在證券交易所中的任何金融資產（如股票）上運行，去中心化概念的弱化必須到位。它將要求受信任的實體在區塊鏈上寫出資產的市場價格是多少，並以某種最低權限的方式（如清除交易雙方之間的金額ultisig）。完全去中心化和完全集中化之間的範圍很廣，而我們上面的DPOS示例，也是中間事物的示例，也可以應用於脫鏈衍生工具。</p>
                <p  >更多內容，感謝您的閱讀！</p>

- title: The Art of Self-Reference
  key: main
  id: 7
  order: 3
  link: art-of-self-ref
  author: Ohad Asor
  date: 发表于2018年5月27日下午8:09分
  content: 这篇文章与前两篇文章一样，阐述了相同的主题。 “The New Tau”这个帖子从TML到Agoras专注于讨论scaling。“From Agoras to TML”这个帖子相反，专注于知识经济。在这里，我们通过强调自我定义来探讨这个问题。 我们这里的主要例子是立法。假定一个创建和修改法律的议会。假设议会有兴趣修改现有的法律。那么，在一个正常的世界里，他们不能随意的去修改法律，而是应该按照修改法律的法律来修改法律。为了区分法律和修改法律的法律，我们称前者为“一阶法律”，后者称为“二阶法律”。三阶法律是一个关于二阶法律（也可能是一阶法律）的法律。
  main_content: <p>这篇文章与前两篇文章一样，阐述了相同的主题。 “The New Tau”这个帖子从TML到Agoras专注于讨论scaling。“From Agoras to TML”这个帖子相反，专注于知识经济。在这里，我们通过强调自我定义来探讨这个问题。</p>
                <p>我们这里的主要例子是立法。假定一个创建和修改法律的议会。假设议会有兴趣修改现有的法律。那么，在一个正常的世界里，他们不能随意的去修改法律，而是应该按照修改法律的法律来修改法律。为了区分法律和修改法律的法律，我们称前者为“一阶法律”，后者称为“二阶法律”。三阶法律是一个关于二阶法律（也可能是一阶法律）的法律.</p>
                <p>像看起来那样，我们需要无限多的法律规则。因为只有无限多的法则，才能避免法律完全不受保护：如果没有修改法律的法律（二阶法律），那么可以任意的修改一阶法律。这还不够：如果一些二阶法律阻止了某些法律的修改，那么我们也可以修改二阶法律，只要我们没有三阶法律来阻止它。</p>
                <p>所以按照这种方法，为了使法律受到保护，我们必须有无限多的法律。从技术上讲，这意味着任何高阶逻辑都是不够的，因为任何公式的阶数都是有限的，并且公式的最大阶数将对应于法律的最大阶数，然后最大阶数的法律将完全不受保护。因此不管如何使用高阶逻辑或类型理论来解决问题的尝试都注定要失败，除非它们包含以下补救措施。</p>
                <p>补救办法是考虑递归规则。正如上面描述的那样，无限阶的法律是必需的。考虑规则：“所有的法律只能在多数投票通过下改变，包括这项法律”。这条法律的阶数是多少？如果你说它是N阶，那么我也可以说它是N + 1阶，因为它也指向它自己，而一个引用N阶定律的定律至少是N + 1阶。所以，这个法律的阶数，可以说是无限的或者没有定义（用任何一种方式）。它指向自己，并创建一个“逻辑无限循环”。</p>
                <p>大家可能熟悉形式上自相矛盾的自述，如说谎者悖论，或简单地“这种说法是错误的”。自我引用的定义不仅可以是矛盾的，而且也是无意义的：“绿色的东西是绿色的”，定义了“绿色的东西”，但是在一个循环定义中，根本没有任何信息。尽管如此，我们的样板法律“所有法律都只能在多数投票通过下改变，包括这项法律”是完美的。它指向自身，但没有问题，我们仍然可以理解并遵循这个规律。如果仅仅因为我们不能在高阶逻辑的意义上附加任何有限的阶数而拒绝这条法律是可笑的。 </p>
                <p>自我引用的定义非常频繁地出现。我们可以定义一个数字X通过“X = 4X-6”.它通过自身的方式来定义X，然而这是一种完全有效的方式来表示X = 2。在编程中，它是关于递归函数，直接或间接调用自己的函数。然而，对这个定义进行编程会立即失败：</p>
                <p><b>“function what_is_x（）：return 4 * what_is_x（） - 6”</b></p>
                <p>这个函数将永远运行，并且不会承认我们的常识，即X = 4X-6是一个简单有效的有限定义。因此，我们确实需要能够以自己的方式定义事物，并且我们可以看到常见的编程和逻辑范式未能做到这一点。 </p>
                <p>将自引用作为语言原语的逻辑系列称为“Fixed-Point Logics”。 自引用，递归，固定点，在计算机科学领域大致上是同义词。 有一个都市传奇说，递归的使用自动意味着不可判定性以及许多范围内（包括法律）的无用性。这可能是因为另一种定义图灵机的方法是使用“递归可枚举集”，将泛型计算与递归绑定在一起。 然而，也并非总是如此。存在可确定的Fixed-Point Logics，例如FO [LFP]和FO [PFP]（都是可确定的逻辑，因为它们在有限的结构上运行）。 我们现在不会详细介绍细节，我只想提到TML是FO [PFP]。</p>
                <p>（对于不熟悉这个概念的读者来说，可判定性非常粗略地意味着可以回答所有相关的问题，过于表达的语言将变得不可判定，因为它要求许多[如果不是大多数]问题需要无限的时间来回答）。</p>
                <p>我们已经指出了一个合理的立法框架，并且展示了其他逻辑框架如何分解。同样，我们展示了常见的编程范例在这些方面也存在问题，我们的替代范例也适用于编程语言。要求法律以可判定的fixed-point logic来编写，是一项非凡且高度具体的要求，但我认为我们证明了没有任何其他方法可行。 </p>
                <p>但是，尽管它消除了很多其他可能性，但还仍然不够。它基本上等同于法律的语言种类：允许递归并使其保持可判定。尽管如此，这种语言和它的使用还有很多事情需要说明，以适合立法。这与被称为KRR（知识表示和推理）的领域有关。 我没有太多要说的：我们基本上采用本体论模型和关系型机器模型。关于本体论模型和关系型机器模型的更多信息，可以参考有关语义Web的资源。</p>
                <p>那么我们接下来从语言到知识，再到在社会背景下如何获得知识来进行论述。从来没有人简单地写下他们所有的意见。意见通常是通过事件和讨论传达出来。 更深入地说，意见来自于对问题的兴趣，甚至更深。</p>
                <p>现在我们来谈谈生活中最重要的事情：问题。我们有一个正确答案的概念。我们甚至可以通过编程来判断给定的问题答案是否正确。 我们对问题的正确答案感兴趣。 但是，我们感兴趣的问题又是什么呢？我们感兴趣的是有趣的问题，这样的定义毫无意义。哪些问题很有趣？</p>
                <p>对于任何有理解能力的人来说，对于“X = 4X-6”这个问题的答案是X = 2是显而易见的。这个具体问题中的信息足以客观地认为X = 2的答案是正确的，无论是人类，机器还是外星人。尽管如此，它仍然没有包含任何关于为什么这是有趣的信息。</p>
                <p>问题是否有趣的判定不仅是主观的，而且本质上始终源于提问者的任意偏好。狗可能想狗刨，而猫可能会想要垫子。不存在“一个有趣的问题”，而是“在特定的时间里，对某些人来说，有趣的问题”。我们的问题来自我们的人性和个人情况。我们被我们感兴趣的问题所定义，远远超过我们给出的答案所定义的。同样，对同样问题感兴趣的人之间的合作，比起同意相同答案的人之间的合作更有意义。许多人会更热衷于发现人们问他们同样的问题，而不是找到给予同样答案的人。因此，问题是tau的一个主要方面，包括问题的提出和超越（例如，问题在开放世界假设与封闭世界假设的设置中的作用）。</p>
                <p>为了清楚起见，我们可以区分“问题”和“查询”。通过查询，我们指的是我们期望能立即得到答案的问题，例如，我们向一台机器输入信息，然后查询该信息的情况。机器不会也不应该返回新的信息，它只会使用我们给它的信息。相 相反，通过“问题”，我们指的是问题，我们不希望得到一个可用的答案。 问题是一种工具，用来定义需要的知识。问题通常出现在知识之前，而不是相反。它们是探讨或探索某些知识领域的工具。一个机器永远无法模拟的工具，但是考虑到人类必要的输入，它可以极大地帮助我们通过讨论这些问题找到正确的答案。</p>
                <p>我们现在可以总结出人与机器在tau上所扮演的角色：人类是为了解决问题，机器是为了获取答案。更广泛地说，我认为这应该是引导任何AI愿景的哲学真理。</p>
                <p>从语言，知识，讨论，协作，选择和知识经济这六个层次，我们现在介绍了如何才能实现社会选择目标（可能指向社会选择过程本身），我们需要非常特定的形式，其中涉及到语言层面（不包括前一篇文章的互联网语言），并且从那里我们涉及到了一些额外的知识和讨论。</p>
                <p>下次：谁来决定？ </p>

- title: 从 Agoras 到 TML
  link: agoras-to-tml
  id: 0
  order: 4
  key: main
  author: Ohad Asor
  date: 发表于2018年3月13日上午9:30分
  content: 在上一篇博文中，我们按时间和概念上的顺序从下至上的讨论了五个阶段：语言、知识、讨论、协作、变化和知识市场。这五个阶段是关于如何建立一个知识社会的，并且我们可以在它上面建立一个知识经济。在这篇博文中，我们回顾一下：我们考虑的是我们所说的知识经济，以及它所需要的是什么，然后进行深入讨论，直到语言
  main_content: <p>在上一篇博文中，我们按时间和概念上的顺序从下至上的讨论了五个阶段：语言、知识、讨论、协作、变化和知识市场。这五个阶段是关于如何建立一个知识社会的，并且我们可以在它上面建立一个知识经济。在这篇博文中，我们回顾一下：我们考虑的是我们所说的知识经济，以及它所需要的是什么，然后进行深入讨论，直到语言</p>
                <p>为了使这些想法更具体，让我们考虑一个去中心化的搜索引擎，这是Agoras的目标之一。谷歌拥有一百万个物理服务器，它们需要爬行、索引和搜索互联网。我不知道他们的数据有多大，但肯定是巨大的。因此，将整个互联网编入索引并实际搜索它，就需要大量的计算能力和数据存储。在一个以分散搜索引擎为特色的分散式网络中，谁将为此买单？</p>
                <p>因为维护一个web搜索引擎的任务依赖于“物理”数据：在某人上网并发现它之前，数据是完全未知的。因此，这样的任务不能完全不受信任，因为不能证明他们下载并索引到搜索引擎中正确的数据，并且没有修改、替换或忽略它。但是，尽管这个问题并不是完全可以解决的，但它仍然可以在一定程度上解决，理论上可以任意降低风险。 </p>
                <p>我们现在不讨论这个主题，但是我们在<b>Zennet</b>的材料上已经讨论过了，例如，<a target="_blank" href="http://zennet/about">http://zennet/about</a>或者在<b>Zennet</b>的<b>bitcointalk</b>中有更多的文档。我的定价公式出现在<a target="_blank" href="http://zennet/about">http://zennet.sc/zennet.pdf</a>。这个公式可以消除错误定价的风险，这是一种可以被显著利用的风险。另一种方法验证不可验证的计算方法是计算相同的东西不止一次（通过随机选择更多的提供者），所以线性增加成本，风险指数级降低。（例如，x10的成本降低^10的风险）。因此，拥有一个去中心化的搜索引擎需要像<b>zennet</b>一样的能力，能够在用户可以接受的风险范围（风险是成本的函数）公平地租用（和出租）计算资源。我们的知识市场肯定需要这样的能力，它是Agoras的三大功能之一。但让我们继续：假设我们有硬件租赁市场，那么在一个去中心化的搜索引擎需要有什么能力呢？</p>
                <p>一个<b>web</b>搜索引擎由用户和维护人员组成。用户提供搜索查询，维护人员快速地回答查询，并且快速地完成查询，他们必须使整个web已经被索引和存储。当然，用户必须向维护人员支付一笔费用，这取决于使用的数量和维护的成本。但是在一个去中心化的网络中，用户和维护人员是完全相同的实体。为了维护网络，我们必须做的就是运行客户端，并参与到索引和搜索中。用户可能每天进行一定数量的查询，而他们的计算机每天可以回答另一个特定数量的查询（对于其他用户来说，没有一个用户会存储整个<b>internet</b>，而您无法预测明天您将查询什么）。计算机，可能比单个用户手动提供的查询数量更大。因此，如果一个家庭用户每天使用数十或数百个“谷歌搜索”，并且还运行一个支持网络的客户端，我希望这样的用户不仅不用付费，而且还可以赚到钱，因为他们会为别人提供比他们消费更多的服务。但我们也会有更重的用户，例如，他会自动地在很大程度上消耗搜索服务。这样的用户将不得不付费，而且很可能不会最终达到收支平衡。这是一场零和游戏，但资金从大实体流向较小的实体。</p>
                <p>好的，我们描述了一个系统，它可以输入一个查询和“询问互联网”，然后引擎返回一个答案，它支持一个生产、定价、运输和平台（Agora）的经济系统，支持知识（关于网络上的文本的知识）系统。现在，它开始讲述它作为知识经济的一个例子。</p>
                <p>如果在这里停留，我们实际上并没有做出多少贡献：所以我们将拥有一个更好的、去中心化的搜索引擎，它为许多用户提供了一些收入，但生活将会或多或少地保持不变。正如我们所知道的，搜索一个web页面和使用Ctrl-F搜索一本同义词典是没有区别的。这就是谷歌或多或少使用的东西，它在互联网上有一个开放的同义词典。重要的是，我们希望将知识融入到我们的知识经济中，而不是“那些词语或它们的等价物在那个网站上被提及”。我们想要上传很多（如果不是大部分）我们的思想、观点和智慧，到互联网上。事实上我们已经那么做了。但是我们所有的搜索引擎都知道要使用Ctrl-F和一本同义词典。也就是说，它在一个非常浅的层次上运作，甚至谈不上“肤浅的理解”。但是人们真正追求的知识，从来都不是这样的。我们不寻求包含某些词语的文档，而是寻找能够真正回答我们问题的文档。同样地，我们也不寻求专业人士，他们所知道的是在互联网上搜索，但当我们寻找专业人士时，我们期望他们对自己的专业知识有深刻的理解，而不是他们提到一袋子单词的能力。否则，我们会在谷歌上做得足够好，不再需要专业人士了。</p>
                <p>我们想要一个未来的电子知识经济。为了更广泛地了解这幅图景，姑且把这篇文章放在一边。一个经济体在没有社会的情况下是不可能存在的，而且它是社会的一部分。毫不奇怪，所有的经济学家都认为他们自己是一种社会科学家。与物理学不同，经济学依赖于纯粹存在于人类的想象中的概念。产生这种经济学现状的原理看似简单，却很深奥：如果没有某种主观的估值（或“效用函数”），我们就无法拥有一个经济。我们有能力说“我更喜欢这个”。可以把这想象成味道：有些人更喜欢巧克力而不是冰淇淋，而有些人则更喜欢吃冰淇淋而不是巧克力。他们甚至可能准备支付不同的价格。归根结底，它归结于广义上的道德价值体系，定义好的和坏的，更好的和更坏的。这些都不是物理术语，而是纯粹存在于我们的想象中。这并不会让它们变得不那么重要。</p>
                <p>让我给出一个真实的例子，一个知识经济的特征，可以通过它的<b>Tau</b>基础设施，使它获得有意义的知识。假设有一些学院或哲学学院采取了艰苦的使命，用一种可理解的语言来形式化整个哲学书籍，他们可能会让你提交问题，并得到依赖于他们昂贵的专有数据库的答案。然后，可以在平台上声明这些数据，使其成为私有的，并且只在付费订阅中加入到特定的讨论中。我们每个人都是一个研究机构，以独特的知识为特色。这些知识应该具有直接的经济价值，即纯粹的知识现金交易。好吧，我们还需要一个“知识社会”作为我们的“知识经济”生活的框架。我们将触及需要它的几个方面，但是让我们跟随我们的路线，谈论改变的能力。经济是一种游戏，随着时间的推移，不可能改变游戏规则是非常不可取的，这也是一种社会选择，高度依赖于伦理价值观。只有社会定义了新的经济（和社会）规则，否则经济的改变在技术上是不会发生的。但是，“改变经济”或“改变社会”意味着什么呢？</p>
                <p>这意味着很多，但我们并不在乎。我们是计算机的人。我们的知识社会和经济，以及<b>Tau</b>和<b>Agros</b>，都是计算机程序。因此，“改变经济/社会意味着什么”有一个非常清晰的实际概念：一个去中心化的网络，它改变了自己的代码。要改变它自己的代码，就像它听起来的那样，是一件敏感的事情，无论是通过实践还是设计，都是出于技术原因和社会原因。旧的tau只考虑了技术方面（甚至是错误的方式），忽视了社会方面。事实上，我们不知道有一些问题是我们不知道的，因为没有最好的答案，例如：谁可以改变规则（在一个分散的环境中）？ 对于这个问题，没有完美的答案，而且每个解决方案都有很大的缺点，但是，由于没有其他的方法，用户将不得不决定他们认为哪个部分解决方案不那么糟糕。因此，“治理模型”最终必须由用户来决定，这是开始讨论平台集中的好处之一，从一开始就对分散式网络的性质达成广泛的、机器辅助的共识。但是，除了“谁能改变规则”之外，在改变的过程中有许多社会方面需要关注，并且有很好的解决方案。如果你对这些方面有一些了解，请参考前面的博客文章（例如，“谁可以投票”vs“谁来决定投票的结果”，这个问题在我们的投票解决方案中变得毫无意义）。</p>
                <p>一个自我修正的核心，是<b>Tau</b>，正如后面的文章中所解释的那样。在我们有能力改变之后，我们可以继续发展电子知识经济。因此，我们在前进的道路上走了两步：从知识市场到变化，也就是从<b>Agoras</b>到<b>Tau</b>。让我们继续通过协作（<b>Beta</b>）、讨论和知识（<b>Alpha</b>）和语言（<b>TML</b>）来回顾。我们会做的很简短。</p>
                <p>协作，正如上面的“改变”，有很多意味，但我们并不在乎，因为我们是“计算机人”。协作意味着一起做一些事情，而我们在计算机世界中所能做的最大的事情就是运行一个程序。任何p2p网络都是一种协作形式：协调执行代码。在<b>Tau</b>网络中，我们将利用<b>TML</b>的语言翻译能力将规范的程序转换成代码的程序,并通过构建和运行一个程序来自动的减少讨论,并且增强程序将逻辑转换为代码的能力,运行它,并协调其在各方的执行。</p>
                <p>我们需要大规模的讨论以达到如下目的，即决定运行哪些代码 (甚至将一个大团体的观点组织在一起)、设定哪些新规则、如何拥有一个电子知识社会,如何形成方便人类的形式化知识,以及如何在数百万或更多的用户的情况下，有效地做到这些。对于这个话题，我别无选择，只能再次向你推荐最后一篇博文</p>
                <p>我们走在了通往知识本身的基本概念的道路上，而语言甚至比知识更重要。我们的知识社会/经济比现有的世界更有成果，机器应能够接触到事物的意义，而不仅仅是它们的书写方式。我们创建了语言的互联网，通过让用户定义新的知识来表示语言（可能与自然语言非常接近），并使不断增长的文档类成为机器可理解的语言（更不用说越来越多的文档）。</p>
                <p>在这篇文章中，我们强调的是金字塔的顶端，而不是它的底部，这与之前的文章相反。我希望这是有帮助的。感谢你的阅读!</p>
                

 
- title: The New Tau
  link: the-new-tau
  id: 1
  order: 5
  key: main
  author: Ohad Asor
  date: 发表于2017年12月31日上午7:27分
  content: 一个团体可以少到几个人，也可以多到几十亿人，当这个团体需要做出某个决策的时候，团体的成员需要反复协商，最终达成某种协议，供全体成员共同遵守执行。这一过程我们称之为社会选择 （Social Choice）。社会选择可以衍生为五个层面，语言（language）、知识（knowledge）、讨论（discussion）、协作（collaboration）和演化（choice about choice）。鉴于社会选择广泛存在于人类社会之中，并且十分重要，我们对此进行了深入细致的分析，提出了一种社会选择机制，使集体协商决策的过程更加合理科学。
  main_content: <p>一个团体可以少到几个人，也可以多到几十亿人，当这个团体需要做出某个决策的时候，团体的成员需要反复协商，最终达成某种协议，供全体成员共同遵守执行。这一过程我们称之为社会选择 （Social Choice）。社会选择可以衍生为五个层面，语言（language）、知识（knowledge）、讨论（discussion）、协作（collaboration）和演化（choice about choice）。鉴于社会选择广泛存在于人类社会之中，并且十分重要，我们对此进行了深入细致的分析，提出了一种社会选择机制，使集体协商决策的过程更加合理科学。</p>
                <p>这种集体协商决策需要克服的一个主要困难在于成员之间的沟通是有限制的，随着团体成员数量的增加，信息的流通会更加低效。这种困难在现实中是天然存在的，并且往往被认为是无法克服的。举例来说，我们很自然地会想到每个人都有权投票的情形，但是如果每个人都有平等的权利提出提案，供全体成员投票，这是一种什么情形呢？</p>
                <p>在日常生活中，我们不需要经常投票，只是会经常表达我们的观点，有时候会一起讨论，达成一致意见或者形成新的共识。而在大型团体比如一个国家，我们仅能想到的是，成员们都有权投票给一些数量有限的提案。这些提案或许是以层级（hierarchical）的方式逐层提出。我们无法想象成员们以非中心化的方式，每个人都有权提出一个提案供全体成员讨论，因为无法保证每个成员的建议都不被忽略，也无法保证每个成员有能力处理如此大量的信息。所以社会选择（Social Choice）在讨论（discussion）这一层面，面临着扩展性的难题。</p>
                <p>迄今为止，没有哪一种方法可以解决讨论（discussion）过程中的扩展性难题。当团体成员比较多的时候（哪怕仅仅几十个人），如果数量增加一倍，带来的效益并不是信息量增倍，而很可能是整体效益减半，甚至一半都不到。</p>
                <p>值得庆幸的是，这一难题可以得到解决。我们能够有效解决讨论（discussion）过程中，信息流动的扩展性难题，使得一万个人的集体协商决策过程比一百个人有效一百倍。然而我们需要机器的帮助，前提是我们需要先对机器进行指导。</p>
                <p>具体来说，这种人机交互只能使用少数几种语言，让机器在讨论（discussion）过程中明白人的意图。由于没有人知道如何使计算机理解自然语言, 我们必须使用机器可理解的语言。我们将详细介绍这一点，在此之前先介绍关于自我修正（self-amendment）的一些知识。</p>
                <p>为了解决以上所述的问题，我们提出了Tau Chain这一去中心化计算机网络项目。我们可以使用Tau Chain汇集成员提出的建议，以及针对各项建议提出支持或者反对的投票信息，经过Tau Chain的讨论（discussion）平台的处理，转化为可供人们执行的决策。而对于我们而言，关于Tau Chain本身的讨论和决策是最重要的。</p>
                <p>所以在Tau Chain这一系统之上讨论的主要事项就是关于Tau Chain本身。Tau 就是关于Tau的讨论（Tau, is a discussion about Tau）。或者可以使用一个更精巧的定义，Tau是X生成Y，并被Y所取代的情形。（Consider a process, denoted by X, of people, forming and following another process denoted by Y. Tau is the case where X=Y）这就是Tau。Tau究竟是什么并不重要, 重要的是它可以改变成任何我们想要的东西。此外, Tau是一个计算机程序, 是一个可以依据用户集体协商决策而进行改变的程序。</p>
                <p>需要指出的是，Tau并不是用来猜测人类的意图，不是通过机器学习更加精准的猜测人类意图的系统。这或许是我们使用逻辑（logic）的主要原因。在这一平台上沟通需要使用像电脑程序一样形式化和确定性（formal and definite）的语言，因为需要处理的是一般的知识, 而不是机器指令。</p>
                <p>基于这一点，Tau这个通过集体协作而进行自我修正的去中心化程序，可以转换成几乎任何我们需要的程序，甚至同时转化成多种程序。实际上，Tau并不仅仅是用于自身的演化，在这个平台之上，不管团体的规模是大是小，任何协作性质的活动都可以展开，比如对知识的整理讨论和分享，对于共识或者分歧的探知，协调各种行动等等，只要这些活动是以程序的形式在Tau平台上展开。</p>
                <p>本文开始提到的关于社会选择的五个层面对应于Tau开发的路线图。这里需要对Tau的路线图做进一步的解释。第一步是TML（Tau Meta Language）和互联网语言的开发。第二步Alpha 是讨论平台（discussion platform）的开发。第三步Beta 是在讨论平台添加后续协作（collaboration）的功能，这样系统不仅能进行知识的汇集，还能够执行程序。前三步并不具备类似于比特币网络的去中心化的特征，这一特征将在第四步引入。到了第四步，Tau将是一个去中心化的具备自我修正特征的社会选择平台（self-amending social choice platform）。第五步，在此基础之上，我们将构建Agoras。Agoras由三个组件构成，一个是知识市场（knowledge market），一个是类似于Zennet的计算资源市场（computational resources market），还有一个是为实施衍生品交易而新设计的经济系统，其特征是不需要开动印钞机就能提供无风险收益。</p>
                <p>为了让机器提升我们讨论和协作的能力，机器需要懂得人类语言的含义，然而迄今为止这一难题还无法解决。机器语言和人类语言并不相通。另一方面，如果人类使用机器语言去分享知识也非常不方便。因为机器语言是由机器指令组成，人类语言对知识的描述具有完全不同的特性。换言之，机器需要的是可操作的信息，人类语言更多的是用来描述和说明。所以Tau的目标，是让我们更多地专注于“知道什么”（"know-what"），让机器去处理“知道怎样做”（"know-how"）。</p>
                <p>为了架起人类语言和机器语言之间的沟通的桥梁，我们建议使用逻辑（logic）(cf. e.g. the article "Knowledge Representation and Classical Logic" by Lifschitz et al)。形式逻辑与人类语言的特性相近，而且可以被机器所使用。但是, "形式逻辑" 并没有什么特别之处, 因为它并不代表任何语言, 而是一个语言类别的模糊描述。</p>
                <p>我们认为通用语言不应该也不可能是唯一的。最佳的语言不可能只是一种，一种语言也无法满足所有需求。因此, 我们提出了一种能够定义新语言的元语言（meta-language），这种语言能够重新定义自己，可以自我修正，这样可以避免走入单一语言满足所有需求的误区。因此我们不仅能够拥有多种语言，而且定义这些语言的元语言能够自我修正，这对于一个能够自我修正的系统而言，是一个重要组成部分。</p>
                <p>事实证明, 逻辑学（logics）虽然并不被公众所熟知，但是可以定义自身，并且具有良好的逻辑属性，比如可判定性。虽然我们已经拥有了通用的图灵机，但是寻找一种具有较少表达属性（expressive），较多信息属性（informative, e.g. decidable）的语言并不是一件简单的事情。我们采用了logic PFP，它的表达属性符合PSPACE-complete，这一点可以参考关于Finite Model Theory的书籍。而且逻辑学能够对自身进行定义，这一点可以参考Imhof, 1999 "Logics that define their own semantics"。</p>
                <p>继续讲互联网语言。上文提到的meta-language ，我们称之为TML (Tau Meta-Language)，用户可以在TML的基础上使用逻辑公式定义新的语言，这样可以做到两种不同的语言描述的文档具有相同的含义。换句话说，定义一个新的语言，需要与已经存在的语言，建立能够保证相同语义（semantics-preserving）的翻译方法。这里的语义指的是本体论 (对象和关系)（ontological，objects and relations），而不是编程语言的操作语义学（operational semantics）。在这基础上，我们能够建立知识互联网，不管使用哪一种语言，只要这种语言的文档能够通过TML转换成另一种语言。</p>
                <p>上述所言并不是指把法语翻译成中文这类翻译，前文已经强调过我们不处理自然语言。当然，从理论上讲，将来或许有人能够在TML的基础上开发出能够完全理解自然语言的东西，但是我们并不指望这些。实际上，现在已经有一些形式化的自然语言很接近完整的自然语言，人类使用起来有很高的舒适度，也足够简单，机器可以理解，所以我们期待TML在某种程度上可以处理人类容易理解的语言。但是TML设计的主要意图是供机器使用。例如，把文档转换成HTML或者维基（Wiki）格式，把高级语言编写的程序转换成机器代码，根据逻辑（logic）编写代码。</p>
                <p>更一般地，我们希望能够把TML做成编译器编译程序。出于对某种语言的逻辑性的考虑，需要一次又一次的编译该语言编写的文档，为了避免这种低效的情况，我们采用Partial Evaluation，这又会给编译器编译程序增加新的优点： Futamura projections。至此, 我们可以用各种基于TML的语言来表达知识和观点, 可以使用这些语言进行交流。考虑一下人与人之间的这种交互，确切地说是人-机器-人之间的这种交互过程，机器并不是与人平起平坐的角色，而仅仅是机器而已，它仅仅是将我们人类要表达的内容组织起来编码，通过这个机器网络传播和处理，供其他人使用。这个流程的优势是，表达起来很简单，理解起来很简单，同时知识是形式化（formalizing knowledge）的。</p>
                <p>具体的讲，一个用户所表达的内容，不需要让其他用户理解，他只需要让机器理解。这项任务在某些方面可能比较简单, 而在其他方面会比较复杂, 但机器肯定比人类更不受组织和规模的约束，机器在扩展性方面具有优势。一个用户将自己的想法以机器可理解的语言形式化以后（formalized），另一个用户不仅可以将其内容翻译成另一种语言，还可以将其组织编排成新的内容，或者与其他用户表达的内容进行比较。这样用户可以从这个机器网络中找到任何问题的答案，因为机器能够完全理解该问题相关的主题，有回答用户提出的所有问题的理论能力（基于可判定性（decidability arises again here）），有了机器的帮助，用户就不需要寻找原作者的表述。</p>
                <p>到了Alpha这一步就超越了这种情况，Alpha是没有规模限制的讨论平台。它是结构化的，像论坛或者社交网络一样可以发帖，发表评论，发表自己的意见，并与好友分享。可以根据某个主题建立群组并进行设置。比如建一个团队协同开发一个软件，起草法律或者合同，或者仅仅是讨论任何有关科学或者哲学或者社会或者是一些毫无意义的想法。</p>
                <p>到目前为止，这个讨论平台似乎没有什么特别之处，然而由于我们使用的是机器可以理解的语言，这个讨论平台具有很多的优势。比如：自动检测同一个人重复的论点；收集讨论过程中每个人表述的内容，总结出一致的意见和不同的意见，把每一种意见的支持者和反对者列出来；把讨论的内容有条理的组织起来，像wiki一样更具有可读性；甚至可以自动评论，比如当你看到某人表达了某个观点，而你以前对相关的主题有过表述或者评论，这是你可以点击“自动评论”，系统基于你之前提供的信息自动表达出你的观点；或者更重要的一个优势是，在一个特定的范围内（可以是整个网络，或者整个团队，或者你的好友，或者是某个主题讨论的参与人员），逐条列出大家都赞成的各项观点。无需惊奇，因为所有内容都是以逻辑（logic）来表述。（或者说我们有一种逻辑能够将表述的内容转换成逻辑，即TML，它可以定义用户表达时所使用的语言）</p>
                <p>在Alpha这一步，我们赋予机器网络很多知识，可能是我们有意输入的，也可能是通过讨论而得到的。此外还形成了我们一致同意的理论, 并且我们都作出了贡献。我们能用这些知识做些什么呢？最终, 在计算机世界, 我们所能做的就是运行计算机程序。到 Beta 这一步, 我们将能够讨论程序的开发, 然后运行程序。在Tau这个网络上, 我们将有一个特殊的团队称为Tau, 这样, 每当团队接受一个新的决策, Tau的代码将会自动修改。到 Beta 这一步, 我们可以实现在Alpha上讨论达成一致的事情。对于某个程序，一旦团队同意修改某些规范, 则无需编写或重写任何代码, 因为它可以自动完成, 所有内容都已处于机器可理解的语言中。依据设计规范来编写代码相当于在TML基础上翻译另外一种语言，当然要完成这个目标，需要开发足够丰富的语言转换工具。这些工作说起来容易做起来困难，相关的细节是高度技术性的。可以说, 在 MSO+λY 领域，上述所说的依据设计规范自动编写代码的工作是前沿的尖端技术。</p>
                <p>选择如何选择，即改变选择机制本身，或者说是改变规则的规则，意味着Tau随着时间不断演化。这本身会变成一个悖论，会限制逻辑的使用。如果规则可以改变自身，他们将不可避免的自相矛盾。那么我们怎样才能够以无悖论的方式对这一过程形式化呢？或许有人会想到高阶逻辑，但这还不够。比如这条规则“所有的规则包括这条规则只能在多数人同意的时候才可以修改”，由于它对自身起作用，所以不是有限阶的。因此, 我们需要递归, 以处理更改规则的规则。这是 TML 中不动点逻辑（fixed-point logic）所包含的一个重要方面, 也是Beta版中λY 演算（λY calculus）的重要内容（Bauer在"On Self-Interpreters For System-T and Other Typed λ-Calculi"中阐述了一种能够自我解释的语言必须有不动点（fixed point），这就把目前所有的编程语言排除在外了）。</p>
                <p>旧版的Tau对规则的改变采取了Nomic的方式。 我们用一个例子解释旧Tau和新Tau改变规则的方式有什么区别。两个律师各自代表某项交易的双方, 他们要起草一份双方能够达成一致的合同。一种方法是，甲律师提出一项条款, 乙律师同意, 则附加该条款, 否则不附加该条款；然后轮到乙律师提出一个条款，甲律师同意, 则附加该条款, 否则不附加该条款；以此类推。这就是Nomic的方案。该方案反映在Tau上，就是对代码持续打补丁。这种方式把各方的意见置于非对称（asymmetry）的位置。关于非对称这个问题以及Tau如何尽可能避免，有很多内容可以阐述，但是现在需要考虑的是新的条款与旧的条款冲突这一情形。如果我们不希望把新旧条款置于不平等的位置，我们必须同等的审查修改新旧条款，而不是以默认的方式删除旧条款。</p>
                <p>另一种方法是，每一轮一方律师提交一个完整的合同草案, 另一方律师可以接受或提出另一草案。要求每个草案在逻辑上一致, 这样我们将不需要处理过去与未来的矛盾。它完全消除了往回看的必要。但这种方法仍然无法扩展。如果我们有100万律师, 他们会读100万份草案吗？</p>
                <p>对于Tau而言，这些草案对应于Tau下一个版本全部代码的备选代码，我们能够以一种相当直截了当的方式处理100万份备选代码（因为代码文件是以逻辑形式化的），计算出每个人都同意的核心部分，并且列出需要解决的要点。我们无需投票，只需要像日常生活中的小组讨论那样表达我们的观点，然后就可以呈现出整体的解决意见的框架。</p>
                <p>还有许多内容需要阐明，我们将在后续的博客和论文中讲述。对于上述讨论的任何问题，尤其是实际中的社会选择和讨论扩展性的问题，我期待您的意见和建议。</p>
               

- title: Tau和真相危机
  link: tau-and-the-crisis-of-truth
  id: 2
  order: 6
  key: main
  author: Ohad Asor
  date: 发表于2016年9月11日凌晨2:25
  content: 我们生活在一个没有人知道法律的世界里。除了个别案件，你不可能知道什么是合法的，什么是非法的。你所能做的就是试着看看法官或警察在你采取行动后的意见，当然他们彼此之间意见也经常不一致。或者你可以咨询律师，他会告诉你没有绝对的答案，其实这只是一个概率问题，不幸的是没有人知道如何计算这个概率。你可以尽自己最大的努力去过一个有作为的生活，按照你所理解的规则或律师指导去遵守规则，但是没有人能保证你不会被认为是罪犯，或者法律行动不会对你不利。同样，一个人可以过着伤害众人的生活，即使系统意识到这一点，也没有任何法律体系会阻止他。这种悲观的情况并非鲜见，也并非只发生在个别地方。据我所知，Franz Kafka对这种情况进行了最好的描述。
  main_content: <p>我们生活在一个没有人知道法律的世界里。除了个别案件，你不可能知道什么是合法的，什么是非法的。你所能做的就是试着看看法官或警察在你采取行动后的意见，当然他们彼此之间意见也经常不一致。或者你可以咨询律师，他会告诉你没有绝对的答案，其实这只是一个概率问题，不幸的是没有人知道如何计算这个概率。你可以尽自己最大的努力去过一个有作为的生活，按照你所理解的规则或律师指导去遵守规则，但是没有人能保证你不会被认为是罪犯，或者法律行动不会对你不利。同样，一个人可以过着伤害众人的生活，即使系统意识到这一点，也没有任何法律体系会阻止他。这种悲观的情况并非鲜见，也并非只发生在个别地方。据我所知，Franz Kafka对这种情况进行了最好的描述。</p>
                <p>自人类学会了说话，就开始有意识或无意识地玩弄文字，并将其引导到任何想要的方向，无论有意或无意。最坏的谎言只包含真理，最坏的犯罪行径也往往是有许可证的，并且语言可以为几乎任何事情辩护。这种“真理危机”是后现代哲学的基础，特别是解构主义的方法，它展示了如何用许多矛盾的方式来解释文本。 “没有真理”是后现代主义的基础。但是，我们能否找到一座真理孤岛，其上社会契约是有用的和有意义的？</p>
                <p>不仅法律不能以绝对的方式被理解，而且甚至不能简单地由绝对的过程来实现。法律必须随着时间的推移而改变，因此我们也需要法律来改变法律，即，我们需要的改变法律的法律的法律……，无限循环。但是，我们仍然没有任何逻辑基础来制定规则，而不仅仅是决定什么是合法的，什么是非法的。这一悖论在Peter Suber的在线书《The Paradox of Self Amendment》的附录中得到了描述。他提供了一个两层系统，其中有可变的和不可变的规则，同时包括转换规则的规则（即，使不可变规则变易或反之亦然）。通过这种方式，我们可以避免法律修改方案的无限循环，但我们仍然停留在“真相危机”中。在这个危机中，没有真理，尤其是当你迫切需要它的时候，尽管法律的目的是要有特定的社会秩序，而不是虚假信息和混沌。</p>
                <p>当从法律的世界中走出来，试图在数字和数学对象的世界里回答类似的问题时，这个任务本身并没变得容易，但更容易论证了。逻辑学家对这些问题已经思考了几个世纪了，并提出了可判定性这个概念。如果该语言的每一个可表达的语句都可以被判定是否遵循了该语言中表达的规则，则称这种语言是可判定的。一个惊人的例子是Godel的定理：如果我们的语言能够表达Peano算法，也就是它包含了自然数1 2 3，……，配备了加法和乘法以及它们的规则（这确实决定了它们的独特之处），那么就会有一些关于Peano算法的真实陈述，无法从其定义中得到证明。因此，为了能够判定每个语句的正确性，将需要无限多个公理。可判定性的另一个例子是Presburger算法：如果我们放弃乘法，只用加法定义数字（以某种方式），我们就可以回到可判定性，每一个可表达的语句都可以在有限的过程中判定为真或假。同样的道理也适用于2000年前欧几里得几何学这一可判定的理论。因此，我们有兴趣创造一个社会过程，在这个过程中，我们只用可判定的语言来表达法律，并在不陷入悖论的情况下，共同形成可修改的社会契约。这就是Tau-Chain的初心。</p>
                <p>上述长篇大论强调了在一般的生活中，特别是在Tau中，可判定性的重要性和中心作用。如果我们希望Tau能够为世界做出真正的贡献，它就必须使用一种可判定的语言。旧Tau的设计旨在满足这些要求，但最近我发现我错了，最初选择的语言是非法判定性的。Martin-Lof Type Theory (MLTT) 只在个别方面有可判定性（比如，相等问题），而非对所有方面的表达都是可判定。这种情况使我得出结论，MLTT是一个错误的选择，应该考虑另一个逻辑。事实上，我在博客文章和视频上的一些声明是错误的，而MLTT整体上没有可判定性的类型检查。MLTT是关于所谓的“非独立类型”，我将试着在这一段中稍微解释一下。我们提到了“措辞”和“类型”。措辞可视为陈述而类型视为满足这些陈述条件的规范。这些规范有多普遍？非独立类型在某种意义上给了它们最大的表达能力：类型可以依赖于措辞，而措辞也可以依赖于类型（这就是“非独立类型”的名称的由来）。我们能够表达我们的措辞语言所能够表达的任何规范，或者更准确地说，类型可以由一个计算程序来表示。程序可能包括规范，而规范也可能包括程序。类型检查是确保措辞确实符合它们的类型的过程。但是如果类型可以是通用程序，我们必须要求它们在有限的时间内执行完毕并返回结果。只有当你能够断言你的类型是可以在有限的过程中计算的，那么类型检查的过程才变得可判定。但是这个任务本身是不可判定的，因为停止的问题是不可判定的。因此，如果你想要在非独立类型上达到可判性，你首先必须越过这个不可判定障碍。这在许多情况下是可能的，因为许多程序可以以可证明终止的形式编写(如原始递归，它是整个函数式编程的基础)。但是，这样的方法是不可能适用于所有的程序的，否则，停止的问题就会成为可判定的。非独立型语言在计算机辅助证明和形式验证的领域得到了广泛的应用，但是他们其实是难以处理的。这种困难不仅源于他们的理论比其他语言复杂得多，而且更困难的部分是说服类型检查器（或终止和整体检查器，目的是试图确保类型检查过程是有限的）你的代码符合它的规范。因此，类型检查过程不是自动的，需要大量的人工干预才能说服它接受真实的陈述，这是一种完全来自于语言的不可判定性的困难。随后，我们就失去了始终、完全自动地决定一个句子是否为真的能力，或者同样地，是否 某个动作（措辞）是合法的（输入良好的）或根据给定的规则判定是非法的。</p>
                <p>解决这种情况的办法是选择一种不同的逻辑，一种“完整”的逻辑。一个完整的逻辑意味着一切都是可判定的，而且不仅仅是它的某些方面（比如MLTT中的等式）。Godel研究表明，每一个完整的逻辑，并且能够表达Peano算法，都将不可避免地不一致。所以为了保证一致性和完整性，我们将不得不放弃一部分的算术。不仅已经知的我们可以使用的完整和一致的逻辑，而且最近这些语言的家族被发现比以前所知的更有表现力。具体地说，自20世纪60年代以来，某些类的单值二阶逻辑（MSO或MSOL）被发现是完整和一致的，但是它们没有令人满意的表达能力。直到2006年，Luke Ong才提出了一种“高阶递归方案”的完整证明，即所谓的“高阶递归方案”，它是一种简单类型（相当非独立类型的）高阶函数语言，带有递归，极大地增强了完全可判定语言的表达能力。从那时起，理论和实践都取得了进步，尤其是Naoki Kobayashi。</p>
                <p>这是一个漫长的旅程，直到我发现我的基本前提是错误的，而且当旅程开始的时候，我并不是一个逻辑学家。幸运的是，我们现在可以将Tau的设计修改成比我们之前认为的更好的东西，即使MLTT是可判定的。Tau有三个优点：直接计算模型的存在，推断程序的能力，以及易用性。MSO理论有一个基于自动机的直接的计算模型。 MSO公式可以被翻译成冗余机，该机器读取一个语句并决定它是否满足这个公式。此外，这些自动机可以以一种独特的方式被最小化，因此我们甚至得到了一个可验证的最优代码。另一方面，MLTT不喜欢被直接翻译成自动机，而是使用逻辑自动连接的方式。MLTT认可一个更一般的概念，程序证明，即证明过程被更松散地指定，并且不存在直接转换到自动机的过程。程序证明不可能存在，因为自动机是一个显式的有限决策过程，而非独立类型不是完全可判定的。</p>
                <p>第二个显著的优势是自动编程，在文献中更常见的称为“程序合成”。如果我们给出一个程序（或规则基础）的规范，机器可以自己设计程序（或规则）吗？这个任务在MLTT上是不可判定的，但是在一个完整的逻辑中，这是可能的。我们可以通过简单地陈述我们期望他们做的事情，并命令机器找到一个我们的需求的结构，这样我们就可以得到正确的项目和合约。由于上述原因，MSO逻辑更简单：它是一种更简单的语言，不需要人工干预来说服真实的陈述确实是正确的。MLTT是一种直觉逻辑，这意味着一种被证明为假的陈述并不一定意味着它的反面是正确的。例如，一个人不能总是用矛盾性来证明。直觉逻辑允许用矛盾性来证明不存在：它可以假定某物存在，推导出矛盾，并由此得出结论它不存在。但它不能支持不存在的矛盾性证明：在直觉逻辑下，假设某物不存在，而产生矛盾并不能证明它的存在。更正式的，直觉逻辑明确否定了被排除的中间法则。 这当然是非常不直观的，并且认可人类犯错误的可能性，尤其是面对复杂结构时。另一方面，MSO是一种经典的逻辑，意味着它包括了被排除的中间法则：在同一时间，任何事物都不可能同时是真和假。中间被完全排除在外，而如果我们将这个规则添加到MLTT中，它就失去了一致性。</p>
                <p>作为一个结论，我们的旅程与我们所期望的在实施方面有所不同。但它最终会得到一个更好的产品，它将给我们一个机会来解决真相危机和在全球社会和电子环境中自我修正悖论。我个人意愿（并承诺）保持全职工作，直到我完成了Tau和Agoras，它们将引入比这里描述的更多的特性。最近，我对我承诺要交付的产品做了一个简单的描述。另一篇文章和另一段视频将会解释更多的细节。如果你愿意帮助实现这些目标，如果你会发现自己（或你的朋友）理解Kobayashi的论文，我将非常乐意与你们合作。</p>
               

- title: "Project Roadmap"
  link: projectroadmap
  key: archive
  id: 3
  order: 7
  author: Ohad Asor
  date: Apr 9, 2016
  content: Tau is a language. It is a programming language, but not only such. It may express virtually any arbitrary knowledge, rules, and processes. Examples are contracts, mathematical proofs, scientific facts and arguments, and legal documents.
  main_content: <p>Beginning with some recap:</p>
                <p>Tau My Life&#58; A Memoir is a language. It is a programming language, but not only such. It may express virtually any arbitrary knowledge, rules, and processes. Examples are contracts, mathematical proofs, scientific facts and arguments, and legal documents. Its power comes from being unambiguous and consistent while still maintaining maximum (finite) expressibility. A more detailed explanation of what consistently decidable means and why it is the strongest Tau's property has a dedicated explanation on the following short talk:</p>
                <p class="text-center width-100 margin-auto"><iframe width="480" height="270" src="https://www.youtube.com/embed/Utggm7cuGbo"></iframe></p>
                <p>This isn't new, this type of language (specifically, Martin-Lof Type Theory [MLTT]) has known implementations. Tau's innovation is by adding DHT and Blockchain primitives to the language, and by that make the language aware of other peers and be able to coordinate with them securely and meaningfully. Another innovation is adapting the RDF language family to MLTT, taking the subject-verb-object format of the famous RDF languages family (e.g. Notation3) and giving it MLTT logic, makes Tau a more accessible, readable, and portable language than other MLTT implementations.</p>
                <p>What we develop now is a compiler to this language, means, something that takes a document written in Tau language together with a query about that document, and resolves the query. But there's another important building block which is shared knowledge and rules.</p>
                <p>The languages incorporate a shared level expressed by the built-in blockchain. Tau-Chain is designed to have a single root chain. This chain contains code, written in Tau language, and this code is being executed. As a metaphor, imagine a piece of code that all it is doing is to download itself from github and execute it, again and again, while the code might be changed and do additional operations in the meanwhile. A Tau client downloads its own code from the root chain, it downloads a block, executes the code in it, and this code instructs how to download and run the next block. By that, the client understands the blockchain according to the network rules that were relevant at that point of time when the block was created. This gives rise to the network being self-defining. Tau begins its genesis block clean of rules, and the rules of the network will then be determined collaboratively over the network by the first users.</p>
                <p>To get a glimpse of what uses such a network gives rise to, see this blogpost. For an description of Tau as a generalized blockchain, see here.  Tau also incorporates the lambda-auth design for verifiable computing, as described here.</p>
                <p>A more detailed use case appears here and is summarized on the following short video:</p>
                <p class="text-center width-100 margin-auto"><iframe width="480" height="270" src="https://www.youtube.com/embed/1SXfYgQxsOA"></iframe></p>
                <p>Many of those use cases are to be built on Agoras. Specifically, we plan to implement over Agoras the code-for-money market, computational resources market (as on Zennet's vision), and a decentralized smart search engine (aiming to obsolete Google), among some other plans. Those require a currency, and Agoras will be a currency implemented using Tau's architecture, inheriting the self-definition and democracy abilities, protocol elasticity, and smart yet comprehensible contracts.</p>
                <p>Tau as for itself comes with no coin and begins completely and inherently equal. It is merely a language with a blockchain, but with far reaching consequences. It is meant to be a platform for decentralized (and offline) applications. Agoras will be only one of them. Tau is designed to leave no incentive to others not to develop over it, e.g. due to its code reuse abilities and the incentive to combine hashes to one root chain, to mention only two aspects.</p>
                <p>The selected mentioned markets that Agoras is planned to implement need abilities that are unique to Tau, and, they give unrefusable answers to some of the most disturbing bottlenecks in the world economy, software development, computational resources, and data together with processing it. An example to additional idea to be implemented on Agoras but not fully developed yet, derivatives market that also implements risk-free interest (without printing new money!).</p>
                <p>Explaining Tau, Agoras, and their implications is not an easy task. We have been working on explanatory materials and had a significant success in spreading the word and the vision, yet this success in explaining the ideas is still very partial. The current materials still doesn't show the whole detailed picture, and are not clear enough. A new website and additional videos are currently under construction. More people are getting involved and trying to explain the ideas in their own words. This process takes time and work, but it is important that enough people will figure out what this is all about, as it is really about something big that has a fundamental impact on all aspects of life (and I understand if I didn't manage to convince you about this point yet). Its success strongly depends on how people understand it, because the users themselves are going to set the rules of the network. The larger the consensus and the more arguments are raised, the more chance to converge towards better rules. We don't have to worry about too much or too complicated information, that's why we have Tau.</p>
                <p>Having more people understanding the project is also important from the pre-sale point of view. We need to distribute the Agoras coins somehow, so we pre-sale them and by that we also hope to receive long-term funding to the projects. Agoras project will require much more effort and human resources than the Tau client if we wish to fulfill our vision in the optimal way. The coin distribution has to be fair at the sense that people were given a reasonable opportunity to understand what this project is really about. The above has to do with the sale going on longer time than usual in the cryptocurrency world, nevertheless the project is quite different than others, and has to be managed as a serious software startup and not according to common practices in the cryptocurrency world that might suite other types of projects.</p>
                <p>Still, early buyers have to be incentivized. We had a weekly 2% raise in price and recently suspended it. But from May 1 the price per token we sell at will be 20 cents, going up 5% monthly (recall it has nothing to do with prices people sell at on the exchange). Beginning from today we offer the following wholesale discount, every additional 10K tokens will give additional 5% discount. So if one purchases 30K tokens, the price for the first 10K is the regular price, then a 5% discount on the next 10K tokens, then 10% discount on the subsequent 10K tokens. All purchasers via email receive a tax invoice with their desired recipient name. A buyer that agrees not to receive the intermediate tokens but only the final coins gets additional 15% discount. The total marginal discount will never go below 50% (as to be fair with earlier buyers).</p>
                <p>This current stage is extremely preliminary, as the implications of the technology aren't even fully explained yet, and even the language itself isn't ready yet. When things will look like they really are, namely, that if it all works as planned then we offer unrefusable replacement to markets of literally dozens of trillions as for today, this will be well reflected in the market cap. Far to mention, when the final coins will take action together with the already implemented futuristic markets.</p>
                <p>For final words, your participation in thinking of the rules of changing the rules is very important. Please give some thoughts, ask questions and have discussions about how you'd like Tau to be like. If we do it right, it'll meaningfully master all mankind's knowledge and way beyond.</p>


- title: "Tau as a Generalized Blockchain"
  link: generalized-blockchain
  key: archive
  id: 4
  order: 8
  author: Ohad Asor
  date: Oct 17, 2015
  content: Bitcoin may abstractly be described as a decentralized machine that appends new data (transactions) to a public shared database (ledger) given certain proofs (signatures).
  main_content: <p>Bitcoin may abstractly be described as a decentralized machine that appends new data (transactions) to a public shared database (ledger) given certain proofs (signatures).</p>
                <p>One immediately asks, what if we take the Blockchain algorithm and allow arbitrary data with multiple public shared databases and with arbitrary proofs? Moreover, can the protocol itself evolve with time? </p>
                <p>Let's break those questions into pieces:</p>
                <p>1. Allowing arbitrary data, Bitcoin's protocol may already encode arbitrary data, but not efficiently. It costs way beyond customary storage networks or services, and the cost is justified – all nodes have to store and process that data.</p>
                <p>2. Multiple public shared databases we'd like to have many different applications over one Blockchain that secures them all, yet we don't want users of one application to be affected by the existence of another application.</p>
                <p>3. Arbitrary proofs, proofs are nothing but computer programs and vice versa. At Bitcoin's scope, the proof is the signature verification function's output, sometimes with addition of scripts (examples of useful scripts at https://en.bitcoin.it/wiki/Contract), yet Bitcoin's scripts are quite weak. So we'd like to allow arbitrary code to “run on the blockchain”, a code that is able to do practically anything that a computer can do.</p>
                <p>4. Self-definition, Since we speak of a shared database of programs, can the network's protocol itself, i.e. the client's code itself, be on-chain and auto-update itself from the chain?</p>
                <p style="margin-top:25px">1 is a special case of 3 since ultimately code can contain data (and that's basically Ethereum, Bitcoin+3). 2 can be achieved by allowing to put many programs on the blockchain, while users pick which program to run. This can be fulfilled by a blockchain containing Java/C++/Python/Precompiled programs, in other words, a decentralized appstore that auto-updates its own code (4). We call this construction Naive Tau.</p>
                <p>Why is it naive? Because apparently it answers all requirements, but de-facto we didn't decentralize anything, the code itself still comes from centralized hands. Since we have to either trust the program's developers for its safety or for other guarantees, we can no longer expect users to trust all programs on the network or a subnetwork. That, even if executing the program is required in order to validate a financial transaction and get into a public ledger. This is unlike, say, Bitcoin's blockchain, that transactions and scripts are “innocent” enough for everyone to safely publish or validate.</p>
                <p>A popular concern among projects dealing with trustless computing is the Halting problem. How can we know that execution of a given code will ever halt, rather stuck all machines on the network? It turns out that under a Turing Complete language, it is impossible to build a software that decides whether given source-code, its execution will ever halt. Ethereum confronted this problem with so-called Gas. The code is indeed executed among all machines participating in the network once they validate the blocks, but the code's author pays per how many computational steps the code has actually performed. If it performs too much calculations (“out of gas”), it is then aborted.</p>
                <p>Obviously, we would like to know much more than only whether a code is halting or not, but also its exact running time given some input, without the need to actually execute it. Similarly, we would like to have custom user-defined guarantees about code without executing it, like that it does not do insecure operations (by any well-defined measures of insecurity, such as connecting to the local network or accessing private files). We will also be very happy to know that the code actually meet its own requirements – namely, that it is correct. We then won't need tedious, full-of-holes QA process, once we have a mathematical proof that a code meets our requirements.</p>
                <p>But it turns out that life aren't so easy. The Halting problem over Turing machines became so famous not because its answer is “No”, but because its answer is both “Yes” and “No”! A contradiction. This situation is mildly called “undecidability”. And this can go arbitrarily far, any such contradiction can be elevated to any statement, supplying a proof that it is true, and also supplying a proof that it is false!</p>
                <p>Because of such pathologies, we can never trust a proof over a Turing complete language.  Completeness here happens to be precisely the completeness Godel spoke about, when he proved that any language that is expressive enough to describe arithmetic, must be either inconsistent or incomplete. Since Turing complete languages are also “Godel-complete”, they are provably inconsistent.</p>
                <p>Godel, therefore, left us with two paths completeness or consistency, while the latter implies decidability, the inability to prove an incorrect statement. Completeness is the ability to prove any correct theorem. Alas, if you can prove any correct theorem, then you can prove also any incorrect theorem!</p>
                <p>This is of course a very unpleasant situation for philosophers, logicians, mathematicians, and computer scientists. But a breaktrough came during the 70s and the 80s by Per Martin-Lof he presented the (now called) Martin-Lof Type Theory (MLTT). MLTT is a programming language with such an expressive power, that it is considered to replace the old foundations of mathematics that consist of first-order classical logic and ZFC set theory. This is as serious as it sounds, new foundations of mathematics. This is the mathematics of the 21st century.</p>
                <p>Why are those foundations “better”?</p>
                <p>1. They are in a language that fits computers too. We can now reformulate all math (a process that has already began, e.g. under the project of Homotopy Type Theory) in a way that a computer can comprehend, verify our proofs, and discover new proofs and theorems.</p>
                <p>2. This system is decidable. Although it picks Godel's consistency path, it turns out that the completeness it is giving up is not so painfulm it is only incomplete with respect to infinite codes. It cannot prove infinitely long mathematical claims or run code that assumes infinite computers (unlike Turing machines that are infinite by definition).</p>
                <p>MLTT covers all what matters finite computers and finite math formulas (infinite sets are welcome, even construction of the reals using Dedekind cuts – after all, this math gets into a finite book). As a result, given a syntactically well-formed code in MLTT together with a proof that “this code will halt” or “this code will never perform more than 1M operations”, we can trust the proof. The decidability guarantees that only true statements can be proved. Moreover, a machine can seek for a proof itself. This is called Automated Theorem Proving, but for complex enough problems their runtime is astronomically high. Yet, a “skeleton” of a complex proof can be supplied by human, letting the machine verifying it by trying to fill the missing parts of the proof.</p>
                <p>Back to our Blockchain construction, we can now put MLTT-compatible language on our blockchain, and we can now supply proofs for anything that we can prove, in a way that a 3rd party is able to trust our proofs. We need not to worry anymore about halting, or about security measures, or about correctness – we can simply require proofs for them all.</p>
                <p>On Tau we take RDF-family languages' syntax (notably Notation3 and Nquads, which consist of triples of “subject verb object”) and give them MLTT's semantics. Equipped with an automated theorem prover that JIT-compiles the proof search (or verification, as a special case), it offers a general-purpose programming language that is decidable, so code can provide proofs about itself (without even getting into self-reference paradoxes!). The language incorporates a Blockchain and DHT as mentioned several times in other locations. Thanks to MLTT and automatic reasoning, non-naive Tau is an intelligent, aware (at the sense it can reason over its own code), safe and trustless decentralized network, while remain so even when allowing general and arbitrary code to run.</p>
                <p>Of course, an explanation of what is Tau should come now and tell more about its features and uses, and we have discussed those in the past in various places (especially on this blog and on bitcointalk). So far on this post we concluded the Naive Tau construction, why it is doomed, and what is the correct way to perform secure multiparty computation.</p>

- title: "Proof of Code Execution"
  link: proof-of-exec
  id: 5
  order: 9
  author: Ohad Asor
  key: archive
  date: Sep 6, 2015
  content: Putting it altogether, code is rules and queries, while the compiler (being essentially an autoprover) follows the rules and their consequences and outputs answers (while performing any side-effects).
  main_content: <p>Putting it altogether, code is rules and queries, while the compiler (being essentially an autoprover) follows the rules and their consequences and outputs answers (while performing any side-effects). This is a closed loop, the code is retrieved from tau-chain upon a new block, using, obviously, some tau client. So we accept and execute block T by executing the code that appeared at block T-1, while block 0 is the genesis block.</p>
                <p>The code of the client should allow users run other tau code according to their preferences. It can be thought as the Appstore/Play application itself, while the network contain many other applications.</p>
                <p>Tau does not only provide a decentralized appstore, but delivers additional and essentially more powerful technologies. We mentioned several times the decidability of the code itself and its consequences. Now we'd like to discuss an independent feature which brings more power to tau applications (or the root chain itself).</p>
                <p>The autoprover is equipped with mechanism of hashing the proof search tree. The prover basically performs a breadth-first search that begins from the query and takes valid steps (according to the rules in the code), and tries to find facts along the search, and by this finishing a proof (a chain of valid moves from facts to the query).</p>
                <p>This tree can be hashed like a Merkle tree. Eventually, the hash of the tree's root is a proof that the whole computation was followed, since one can replay the computation and verify the hash. There are much more efficient methods than replaying the whole tree, as in lambda-auth which presents the algorithm we intend to implement.</p>
                <p>By that, one can prove and verify a local execution of code. Exogenic information (like IO) is treated as Monads, IO is a monad and is not an Auth type. For more information about monads please refer to functional programming literature, but note that this weakness of IO isn't always a trouble, when a user A knows they're connecting to server B, they can trust B's proof of flow that originates from the requests A initiated locally.</p>
                <p>How this can elevate crowd computing, and the performance issues arising at this scope, will be a discussion from some other time. Let's mention some more specific applications for now. One example would be an exchange. The exchange can reveal its own code, and constantly provide proofs that that very code was executed. Another example would be a casino, proving that the whole game indeed followed the rules, including, say, a certain hash computation for random number generation. Also, serving as a DHT or even vanilla Bitcoin client can be proved.</p>
                <p>A derived feature is the ability to verify participation on the network itself, one can prove that they ran a tau client, and designers of voting schemes may rely on this ability. It is also possible to automatically award coins given a proof of execution (over say Agoras, but not over non-tau coins like BTC), just like it is possible to set any rules to any proof.</p>
                <p>I guess that would be enough to ignite the imagination. The 21st advancements of decentralization, cryptography, provability and verifiable computing, open frontiers to a new kind of networking abilities and experience.</p>

- title: Decentralized Democracy and the Role of the First Users
  link: decentralized-democracy
  author: Ohad Asor
  id: 6
  order: 10
  key: archive
  date: Sep 1, 2015
  content: Recently we mentioned several times the logical and technological properties of tau, and now maybe it is time to take a step back and look at the broader picture. We mentioned that tau's programming language is actually rules and logic. 
  main_content: <p>Recently we mentioned several times the logical and technological properties of tau, and now maybe it is time to take a step back and look at the broader picture. We mentioned that tau's programming language is actually rules and logic. We meet rules and logic in many other aspects of life, a relatively small example is that the pure logic structure in solutions to existing problems can be used automatically to cope with unsolved problems, even in an entirely non-related field, like some Chemical structure being isomorphic to some existing computer program.</p>
                <p>This is still a certain use case and is aside the main point, and the main point is decentralized democracy.</p>
                <p>Tau is able to formalize laws, query their consequences, and verify their consistency. It is able to do so in a fully decentralized mode. Tau cannot directly interact with the laws of reality, but it defines its own rules. The network is self-definable and self-amendable. The software client is a compiler that downloads source code from the blockchain and executes that code. The code may (and should occasionally) vary from block to block. Essentially, the most important part of the client's code is the conditions for accepting the next block.</p>
                <p>The rules, protocol, and specific behavior of the network are of course a main factor in the evolution of the network. But specifying them is not our first task upon genesis. Our first task is to specify how rules can be changed, somehow disregarding what those rules actually are.</p>
                <p>Tau's logic and infrastructure allow separation of Contexts. By Context we mean a set of rules that applies only to participants that actively wish to subscribe to that context. The terminology comes from the RDF world, tau's language is formed by quadruples of subject-verb-object-context, so the fact or rule described in "subject-verb-object" applies only at the given context. Nevertheless, code reuse across contexts is possible, and is commonly denoted as context1:subject context2:predicate etc. Contexts can also be pegged on the root chain as sidechains can be pegged on Bitcoin's chain.</p>
                <p>On every context, one may have any kind of custom rules. So the root chain should not intervene on what happens in custom contexts, but define only the rules vital for its own existence. Tau can be bootstrapped with simple arbitrary rules, even roster of first participants, or centralized insertion of code by us. Whatever those rules will be, they are temporary, and our first task is to define how and when rules can be changed at all. Afterwards, we follow the process of rule-making we formalized at the first step, and define together the rules themselves. We, tau's developers, will be highly active at those post-genesis processes, but we will not hold any extra power. Each one of us will begin at genesis as equal exactly like any one else. </p>
                <p>We put a technology for decentralized democracy on the table, that can scale from democracy over a small club in the form of Context tau, into, who knows, maybe even state laws. I see no technological barrier for that. Nevertheless, we also do not have any magical ultimate set of rules.</p>
                <p>The task is hard, and the philosophical questions are overwhelming. But there is a limit to what technology can do. It can give us a platform for decentralized democracy, but it cannot set the rules for us. I cannot exaggerate about the importance of the task of bootstrapping a decentralized democracy and forming its "constitution", therefore I won't, and will only mention that I guess that many readers share the same feeling with me - that we probably can do at least slightly better than our current situation.</p>
                <p>Obviously, the last thing we can do as developers of a democratic system is to set its rules ourselves.</p>
                <p>Formalizing a real-life decentralized democracy is not the first users' duty, of course. It is a much larger-scale process. The first users will need to define how to change the rules of the root chain - not even deal with the technical details like the maximum block size, but what happens if we want to change the block size, namely what are the conditions for a root-chain's rule change. It is an interesting litmus test as for itself. How would the rules of changing the rules evolve given our new logical and decentralization abilities, one can only barely imagine. Let's all hope that tau will actually evolve into collaboration of morals, not only economics, code and knowledge.</p>
                


