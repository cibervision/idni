- title: El arte de la autorreferencia
  key: main
  id: 7
  order: 1
  link: art-of-self-ref
  author: Ohad Asor
  date: Publicado el 27 de mayo de 2018, a las 5:09 AM 
  content: Esta publicación, como las dos anteriores, arroja luz sobre los mismos temas. La publicación "La nueva Tau" pasó de TML a Agoras y se centró en escalar las discusiones. El post "De Agoras a TML" fue al revés, y se centró en la economía del conocimiento. Aquí abordamos el tema enfatizando en la autodefinición
  main_content: <p>Esta publicación, como las dos anteriores, arroja luz sobre los mismos temas. La publicación "La nueva Tau" pasó de TML a Agoras y se centró en escalar las discusiones. El post "De Agoras a TML" fue al revés, y se centró en la economía del conocimiento. Aquí abordamos el tema enfatizando en la autodefinición.</p>
                <p>Nuestro principal ejemplo aquí será de legislación. Considere un parlamento que crea y cambia leyes. Supongamos que el parlamento está interesado en cambiar una ley existente. Bueno, en un mundo normal, no pueden ir y cambiar la ley, ya que debería haber leyes para cambiar las leyes. Distinguiendo entre leyes y leyes para cambiar las leyes, nos referimos a las primeras como "leyes de primer orden" y, a estas últimas, como "leyes de segundo orden". Una ley de tercer orden sería una ley que se refiere a las leyes de segundo orden (y posiblemente de primer orden también).</p>
                <p>Como se puede observar, necesitaremos infinitos órdenes de leyes, por lo tanto, infinitas leyes. De este modo se deja la ley completamente desprotegida&#58; si no hay leyes para cambiar las leyes (leyes de segundo orden), entonces no hay absolutamente nada que impida que se puedan cambiar las leyes de primer orden. Y eso no es suficiente&#58; si alguna ley de segundo orden está impidiendo algún cambio en la ley, también podemos cambiar esa ley de segundo orden, siempre que no tengamos una ley de tercer orden que lo impida.</p>
                <p>¿Entonces de acuerdo con este enfoque, para tener algún tipo de protección contra el cambio arbitrario de la ley, es necesario tener infinitas leyes. En términos técnicos, significa que ninguna lógica de orden superior sería suficiente, ya que cualquier orden de fórmula seguirá siendo finito, y el orden máximo de una fórmula corresponderá con el orden máximo de una ley, que luego estaría completamente desprotegida frente a la modificación, como se ha comentado anteriormente. Esto muestra cómo cualquier prueba para resolver éste problema usando lógica de alto orden o teoría de tipos está condenada al fracaso, a menos que incorporen el siguiente remedio.</p>
                <p>El remedio consiste en considerar reglas recursivas. Las reglas de orden infinito, como se muestra, son una necesidad de la vida cotidiana. Considere la ley&#58; "todas las leyes pueden cambiarse solo por mayoría de votos, incluida esta ley". ¿Cuál sería el orden de esta ley? Si dices que el orden es N, entonces se puede decir que es de orden N + 1 realmente, porque se refiere a sí misma, y una ley que se refiere a un orden N es por definición de orden al menos N + 1. Entonces, el orden de esta ley es realmente infinito o indefinido. Se refiere a sí mismo y crea un "bucle lógico infinito".</p>
                <p>El lector puede estar familiarizado con las declaraciones autorreferenciales en forma de paradojas, como la paradoja del mentiroso, que simplemente dice&#58; "esta afirmación es falsa". Las definiciones autorreferenciales pueden no solo ser contradictorias, sino también no tener sentido&#58; "las cosas de color verde son aquellas que tienen color verde", define "cosas de color verde", pero en una definición circular que no nos proporciona ninguna información. Sin embargo, nuestra ley de ejemplo "todas las leyes solo pueden cambiarse por mayoría de votos, incluida esta ley" tiene un sentido perfecto. Se refiere a sí misma, pero no hay problema con eso, aún podemos entender y cumplir esta ley. Sería ridículo rechazar esta ley simplemente porque no podemos atribuirle ningún orden finito en el sentido de una lógica de alto orden.</p>
                <p>Las definiciones por autorreferencia aparecen con mucha frecuencia. Podemos definir un número X por "X es el número tal que X = 4X-6". Se define X por sí mismo, pero es una forma perfectamente válida de decir X = 2. En la programación, se trata de funciones recursivas, funciones que se autodenominan, directa o indirectamente. Sin embargo, la programación ingenua de esta definición fallaría inmediatamente:</p>
                <p><b>"función que_es_x()&#58; devuleve 4*que_es_x() - 6"</b></p>
                <p>Esta función se ejecutará para siempre y no admitirá nuestro sentido común que nos dice que  X = 4X-6 es una definición finita válida simple.</p>
                <p>Entonces, realmente debemos ser capaces de definir las cosas en términos de sí mismos, y podemos ver cómo la programación común y los paradigmas lógicos no lo hacen.</p>
                <p>La familia de lógicas que incorporan la autorreferencia como lengua primitiva se denomina "Lógica de punto fijo". Autorreferencia, recursión, punto fijo, son más o menos sinónimos en el campo de la informática. Hay una leyenda urbana que dice que el uso de la recursividad implica automáticamente la indecidibilidad y, por tanto, es inservible en muchos ámbitos, incluido el alcance de la ley. Probablemente esto se deba a que otra forma de definir las máquinas de Turing es usar "Conjuntos recursivamente enumerables", vinculando el cálculo genérico con la recursión. Sin embargo, este no es siempre el caso. Existen lógicas decidibles de punto fijo, por ejemplo FO [LFP] y FO [PFP] (ambas son lógicas decidibles porque operan sobre estructuras finitas). No vamos a entrar en detalles ahora, solo mencionaré que TML es FO [PFP].</p>
                <p>(Decidibilidad significa de manera aproximada, para el lector que todavía no está familiarizado con el concepto, que es posible responder a todas las preguntas relevantes. Un lenguaje demasiado expresivo se volverá indecidible porque requerirá muchas [si no la mayoría] de las preguntas para necesitar un tiempo infinito en responder).</p>
                <p>Hemos señalado un marco lógico que tiene sentido para la legislación y que muestra cómo se rompen otros marcos lógicos. Del mismo modo, demostramos que los paradigmas de programación comunes también se desmoronan en estos aspectos, y que nuestro paradigma alternativo también es viable para los lenguajes de programación. Requerir que la ley se escriba en una lógica decidible de punto fijo es un requisito altamente no trivial y altamente específico, pero creo que queda demostrado que realmente no hay otro camino por dónde ir</p>
                <p>Pero, por supuesto, a pesar de que elimina tantas otras posibilidades, todavía no es suficiente. Básicamente equivale al tipo de lenguaje de la ley&#58; permitir la recursión y mantenerla decidible. Aún y así, se deben decir muchas más cosas sobre dicho lenguaje y su uso, para que sea adecuado para la legislación. Esto tiene que ver con el campo llamado KRR (Representación del conocimiento y razonamiento). No tengo mucho que decir al respecto&#58; básicamente adoptamos el modelo ontológico junto con el modelo de máquina relacional. Para obtener más información acerca de la representación del conocimiento como ontologías y relaciones, puede referirse a los recursos sobre la Web Semántica.</p>
                <p>¿Entonces, pasamos del lenguaje al conocimiento, a cómo se adquiere el conocimiento en un entorno social? Bueno, nunca es el caso que la gente simplemente escriba todas sus opiniones. Las opiniones son comunicadas por (y también surgidas de) eventos y discusiones. Más profundamente, las opiniones surgen del interés, o incluso más profundo, de las preguntas.</p>
                <p>Y ahora llegamos a hablar sobre lo más importante en la vida&#58; las preguntas. Tenemos la idea de una respuesta correcta. Incluso podemos programar las computadoras para que digan si una respuesta dada a una pregunta determinada es correcta. Estamos interesados en respuestas correctas a nuestras preguntas. Pero, ¿cuál sería el tipo de preguntas que nos interesan? Bueno, estamos interesados en preguntas interesantes, otra definición circular que no tiene sentido. ¿Qué preguntas son interesantes?</p>
                <p>Si bien la respuesta a la pregunta "para la que X tenemos X = 4X-6" es X = 2 es correcta para cualquier ser inteligente, para cualquiera que pueda entender la pregunta. La información en esta pregunta específica es suficiente para considerar objetivamente la respuesta X = 2 como correcta, sin importar los humanos, las máquinas o los alienígenas. Aún y así, no contiene absolutamente ninguna información sobre por qué sería interesante, si es que hay alguna.</p>
                <p>Las preguntas que son interesantes, no solo son subjetivas, sino que inherentemente siempre se derivan de las preferencias arbitrarias del solicitante. Un perro puede pedir cavar y un gato puede pedir una estera. No hay tal cosa como "una pregunta interesante", sino "una pregunta interesante para ciertos seres en cierto momento". Nuestras preguntas provienen de nuestra naturaleza humana y nuestra naturaleza personal. Estamos definidos por las preguntas que encontramos interesantes, mucho más de lo que nos definen las respuestas que damos. Del mismo modo, la cooperación entre personas interesadas en las mismas preguntas tiene mucho más sentido si se compara con la cooperación entre personas que aceptan las mismas respuestas. Y muchos estarían mucho más interesados en encontrar personas que hicieran las mismas preguntas que ellos, que encontrar personas dando las mismas respuestas. Las preguntas son, por lo tanto, un aspecto importante de tau, incluidos los puntos planteados y más allá (por ejemplo, el papel de las preguntas en el escenario de la suposición del mundo abierto frente al supuesto del mundo cerrado).</p>
                <p>Para mayor claridad, podemos distinguir entre "preguntas" y "consultas". Por consultas nos referimos a preguntas en las que esperamos tener una respuesta inmediata, por ejemplo, el caso donde alimentamos una máquina con información, y luego consultamos esa información. La máquina no devolverá nueva información y no debería, solo usará la información que le hayamos dado. Por el contrario, por "preguntas" nos referimos a preguntas en las que no esperamos tener una respuesta disponible todavía. Una pregunta es una herramienta para definir qué conocimiento se desea. Las preguntas suelen venir antes del conocimiento, y no al revés. Son una herramienta para enfocar una discusión o una exploración en ciertas áreas de conocimiento. Una herramienta que la máquina nunca podrá simular, pero dado el aporte humano de qué preguntas son interesantes, puede ayudarnos en gran medida a encontrar respuestas correctas mediante discusiones sobre esas preguntas.</p>
                <p>Ahora podemos concluir con el papel del pueblo frente al papel de la máquina, en tau&#58; los humanos son para las preguntas, y las máquinas son para las respuestas. En términos más generales, veo esto como una verdad filosófica que debe guiar cualquier aspiración de IA.</p>
                <p>De nuestros seis pasos&#58; lenguaje, conocimiento, discusión, colaboración, elección y economía del conocimiento, ahora cubrimos cómo para alcanzar el objetivo de la elección social, éste debe referirse al proceso de elección social en sí, necesitamos tipos muy específicos de formalismos que descienden al nivel del lenguaje en si (sin cubrir el internet de lenguajes de publicaciones anteriores) y, desde allí, hemos tocado algunos aspectos adicionales relacionados con el conocimiento y la discusión.</p>
                <p>La próxima&#58; ¿Quién decide?</p>


- title: De Agoras a TML
  link: from-agoras-to-tml
  id: 0
  order: 2
  key: main
  author: Ohad Asor
  date: Publicado el 12 de marzo de 2018, a las 6:30 PM
  content: En la última publicación del blog pasamos por nuestras cinco etapas en orden ascendente cronológica y conceptualmente&#58; lenguaje, conocimiento, discusión, colaboración, cambio y mercado del conocimiento. Los primeros cinco pasos son sobre la creación de una sociedad del conocimiento, desde allí, podemos construir una economía del conocimiento encima. En este post vamos hacia atrás&#58; consideramos lo que queremos decir con economía del conocimiento y qué se requiere para que eso suceda, y bajamos por la jerarquía hasta el lenguaje.
  main_content: <p>En la última publicación del blog pasamos por nuestras cinco etapas en orden ascendente cronológica y conceptualmente&#58; lenguaje, conocimiento, discusión, colaboración, cambio y mercado del conocimiento. Los primeros cinco pasos son sobre la creación de una sociedad del conocimiento, desde allí, podemos construir una economía del conocimiento encima. En este post vamos hacia atrás&#58; consideramos lo que queremos decir con economía del conocimiento y qué se requiere para que eso suceda, y bajamos por la jerarquía hasta el lenguaje.</p>
                <p>Para hacer las ideas más concretas, consideremos un motor de búsqueda descentralizado, que fue uno de los objetivos de Agoras que luego se generalizó en el concepto de economía del conocimiento. Google tiene ~ 1M de servidores físicos que necesitan rastrear, indexar y buscar en Internet. No sé cómo de grandes son sus bases de datos, pero deben ser enormes. Por lo tanto, para tener todo el Internet indexado y poder buscarlo, uno necesita enormes cantidades de poder de cómputo y almacenamiento de datos. En una red descentralizada con un motor de búsqueda descentralizado, ¿quién va a pagar por eso?</p>
                <p>La tarea de mantener un motor de búsqueda web depende de datos "físicos"&#58; datos que son completamente desconocidos hasta que alguien ingresa a Internet y los descubre. Por lo tanto, dicha tarea no puede ser completamente infundada, ya que no se puede probar que descargaron e indexaron en el motor de búsqueda los datos correctos y no los modificaron, reemplazaron u omitieron. Pero a pesar de que este problema no es completamente solucionable, todavía se puede resolver en cierta medida probabilística, con riesgos que pueden reducirse arbitrariamente, teóricamente. No cubriremos todo este tema ahora, pero lo hicimos con los materiales de Zennet, cf. p.ej. <a target="_blank" href="http://zennet.sc/about">http://zennet.sc/about</a> o más documentos en el hilo bitcointalk de Zennet. Mi fórmula de fijación de precios aparece en <a target="_blank" href="http://zennet.sc/zennetpricing.pdf">http://zennet.sc/zennetpricing.pdf</a>, que elimina el riesgo de manipulación de precios, un riesgo que puede explotarse significativamente. Otra forma de verificar probabilísticamente los cálculos no verificables es calcular lo mismo más de una vez (escogiendo aleatoriamente más proveedores), por lo que aumentar el costo de forma lineal disminuye el riesgo de forma exponencial (por ejemplo, x10 mayores rendimientos de costos, equivale a ^10 menos riesgo).</p>
                <p>Por lo tanto, tener un motor de búsqueda descentralizado requiere capacidades tipo Zennet, la capacidad de rentar (y alquilar) recursos computacionales, bajo un riesgo aceptable en términos del usuario (en función del costo). Nuestro mercado de conocimiento seguramente requerirá tales capacidades, y por lo tanto es uno de los tres ingredientes principales de Agoras. Pero continuemos&#58; digamos que tenemos mercado de alquiler de hardware, ¿qué hay detrás de un motor de búsqueda descentralizado?</p>
                <p>Un motor de búsqueda web se compone de usuarios y los que lo mantienen. Los usuarios proporcionan consultas de búsqueda, y los proveedores responden las consultas rápidamente, y para hacerlo rápidamente deben tener toda la web indexada y almacenada. Naturalmente, los usuarios tienen que pagar a los que mantienen un pago que depende de la cantidad de uso y el costo de mantenimiento.</p>
                <p>Pero en una red descentralizada, los usuarios y los que mantienen son en realidad la misma entidad. Para mantener la red, todo lo que uno tiene que hacer es ejecutar el cliente y, por lo tanto, participar en la indexación y la búsqueda. Un usuario puede realizar una cierta cantidad de consultas por día, mientras que su computadora puede responder otra cantidad determinada de consultas por día (para otros usuarios, ningún usuario almacenará toda la Internet, ya que usted no puede predecir lo que consultará mañana). La computadora, probablemente puede responder a, en orden de magnitud, más consultas que las que un usuario promedio puede proporcionar manualmente. Entonces, un usuario particular que utiliza docenas o cientos de "búsquedas en línea" por día y también ejecuta un cliente que admite la red, esperará no solo que no tenga que pagar, sino que gane, ya que estará abasteciendo a otros, proporcionando más de lo que consume. Pero también tendremos usuarios más exigentes, de modo que, por ejemplo, consuman los servicios de búsqueda automáticamente en grandes cantidades. Dichos usuarios deberán pagar y probablemente no acaben llegando a un punto de equilibrio. Es un juego de suma cero, pero el dinero fluye de las grandes entidades a las más pequeñas.</p>
                <p>De acuerdo, describimos un sistema en el que se puede escribir una consulta y "preguntar en Internet", y el motor devuelve una respuesta, junto con un sistema económico que admite la producción, fijación de precios, envío y arena (ágora) de algún conocimiento (el conocimiento del texto en la web). Ahora comienza a sonar como un ejemplo de economía del conocimiento.</p>
                <p>Si nos detenemos aquí, en realidad no contribuimos mucho&#58; tendremos un motor de búsqueda mejor y más descentralizado que da a muchos usuarios algunos ingresos, pero la vida continuará más o menos igual. La búsqueda, tal como la conocemos, no es diferente de buscar en una página web con Ctrl-F junto con un diccionario. Eso es lo que usa Google más o menos, Ctrl-F es Internet con un tesauro abierto. Pero sacar una economía del conocimiento tiene muchas más posibilidades. Es importante destacar que nos gustaría incorporar a nuestra economía del conocimiento un conocimiento más profundo y más significativo que "esas palabras o sus equivalentes se mencionan en ese sitio web".</p>
                <p>En última instancia, nos gustaría subir muchos (si no la mayoría) de nuestros pensamientos, opiniones e intelecto a Internet. Nosotros ya lo hacemos, pero todo lo que los motores de búsqueda saben hacer es usar Ctrl-F y un diccionario, es decir, operan a un nivel muy superficial, ni siquiera llegan a una "comprensión superficial". Pero el conocimiento que la gente realmente busca nunca es de esta manera. No buscamos documentos que contengan ciertas palabras, sino documentos que respondan nuestras preguntas. Del mismo modo, no buscamos profesionales que todo lo que saben hacer es buscar en Internet, ya que cuando buscamos profesionales, esperamos de ellos una comprensión profunda de su tema de especialización, y no su capacidad de mencionar un montón de palabras. De lo contrario, lo haríamos suficientemente bien con Google y ya no necesitaríamos profesionales.</p>
                <p>Nos gustaría tener una economía de conocimiento electrónica futurista de todo esto. Para arrojar una luz más amplia sobre el tema (y dejando de lado para este post toda la parte monetaria de la economía, las características monetarias que Agoras apoyará), una economía no puede existir sin una sociedad, ya que es inherente a ésta. Como era de esperar, todos los economistas se consideran a sí mismos como un tipo de científicos sociales. A diferencia de la física, la economía depende y no puede definirse sin conceptos que existen puramente en la imaginación humana. El principio que produce este estado de economía es simple pero muy profundo&#58; no podemos tener una economía sin una valoración subjetiva (o "función de utilidad"), es decir, la capacidad de decir "Prefiero esto sobre eso". Puede pensarlo como el sabor&#58; algunos prefieren el chocolate al helado, mientras que algunos locos prefieren el helado al chocolate. Incluso podrían estar dispuestos a pagar precios diferentes. En la línea de fondo, se trata de sistemas de valores éticos en el sentido amplio, definiendo lo bueno y lo malo, lo mejor y lo peor. Que de hecho no son términos físicos, sino que existen puramente en nuestra imaginación, y esto no los hace menos importantes.</p>
                <p>Permítanme dar un ejemplo (realmente) sencillo de una característica de un conocimiento económico que se puede aplicar sobre Ágoras gracias a su infraestructura subyacente de Tau, dándole acceso a un conocimiento significativo. Supongamos que hay algún instituto o facultad de filosofía que tomó la dura misión de formalizar libros de filosofía completos en un lenguaje tau-comprensible. Es posible que quieras enviar preguntas y al obtener las respuestas, debido a que se basan en su costosa propiedad de base de datos, tengas que pagar. Luego, se puede declarar esta información, a través de la plataforma, para que sea privada, y para incorporarla en ciertas conversaciones solo mediante suscripción de pago.</p>
                <p>Cada uno de nosotros es un instituto de investigación de algo que presenta un conocimiento único. Tal conocimiento debe tener un valor económico directo, es decir, una transacción de conocimiento-dinero.</p>
                <p>De acuerdo, también necesitamos una "sociedad del conocimiento" para que sea el marco en el que vive nuestra "economía del conocimiento". Tocaremos varios aspectos en los que es necesario, pero sigamos nuestra ruta y hablemos sobre la capacidad de cambiar. Una economía, es un juego, y es altamente indeseable no poder cambiar las reglas del juego a lo largo del tiempo, que es nuevamente una opción social y que depende en gran medida de los valores éticos. Solo la sociedad decide las nuevas reglas económicas (y sociales), ya que de lo contrario técnicamente no va a suceder. Pero, ¿qué significa "cambiar la economía" o "cambiar la sociedad"?</p>
                <p>Significa mucho, pero no nos importa. Somos personas conectadas. Nuestro conocimiento, sociedad y economía, Tau y Agoras, son programas de ordenador. Entonces, la pregunta "¿qué significa cambiar la economía / sociedad?" desemboca en un concepto práctico muy claro&#58; una red descentralizada que cambia su propio código.</p>
                <p>Cambiar su propio código, como suena, es algo delicado, tanto por la práctica como por el diseño, tanto por razones técnicas como sociales. El viejo tau consideraba solo el aspecto técnico (e incluso de una manera equivocada), y descuidaba el aspecto social. De hecho, hay preguntas de las que no sabemos dar una respuesta previa, ya que no hay una respuesta concreta, por ejemplo&#58; ¿quién puede cambiar las reglas (en un entorno descentralizado)? No hay una respuesta perfecta para esta pregunta, y cada solución sufre de importantes desventajas, sin embargo, como no hay otra manera, los usuarios tendrán que decidir qué solución parcial consideran mejor. Entonces, el "modelo de gobernanza" tendrá que ser decidido en última instancia por los usuarios, y ese es uno de los beneficios de comenzar la plataforma de discusión de forma centralizada, el alcanzar un consenso amplio y asistido por la máquina sobre la naturaleza de la red descentralizada desde su inicio.</p>
                <p>Pero aparte de "quién cambia las reglas", hay muchos aspectos sociales en el proceso de cambio que requieren atención y tienen buenas soluciones. Para conocer algunos de esos aspectos, consulte el blog anterior (por ejemplo, "quién vota" versus "quién decide qué votar", una pregunta que no tiene sentido dada nuestra solución, ya que no hay posibilidad de voto).</p>
                <p>Un núcleo auto-corregible, es el Tau, como también se explica en la última publicación. Después de que tengamos la capacidad de cambiar, podemos proceder a una economía de conocimiento electrónica en evolución. Así que cubrimos dos pasos en nuestro camino hacia abajo&#58; del mercado del conocimiento al cambio, es decir, de Agoras a Tau. Sigamos retrocediendo a través de la colaboración (Beta), la discusión y el conocimiento (Alfa) y el lenguaje (TML). Lo haremos en breve.</p>
                <p>La colaboración, como "cambio" anterior, significa mucho, pero no nos importa, ya que somos personas conectadas. Colaborar significa hacer algo juntos, y lo máximo que podemos hacer en el mundo de la informática es ejecutar un programa. Cualquier red p2p es una forma de colaboración&#58; ejecución coordinada de código. En Tau utilizaremos las capacidades de traducción de TML para convertir la especificación de los programas al código de los programas de forma automática, y gracias a eso, construir y ejecutar un programa en conjunto, se reducirá a discusiones, mejoradas con la capacidad de convertir la lógica en código, ejecutarlo y coordinar su ejecución entre las partes.</p>
                <p>De aquí a las discusiones. Para acordar qué código ejecutar (o incluso organizar las opiniones de un grupo grande), qué nuevas reglas establecer, y para tener realmente una sociedad de conocimiento electrónica, y para formalizar el conocimiento en un proceso humano-conveniente, y para tener todo esto de forma efectiva en una escala muy grande (millones o más de usuarios), necesitamos discusiones que escalen. Y para este tema no tengo más remedio que referirme nuevamente a la última publicación de blog.</p>
                <p>Hemos profundizado hacia los conceptos fundamentales del conocimiento en sí, y un lenguaje que es aún más fundamental que el conocimiento. Nuestra sociedad / economía del conocimiento puede ser más fructífera que en el mundo actual, solo si la máquina tiene acceso al significado de las cosas dichas, y no únicamente a cómo están escritas. Creamos el Internet de lenguajes, permitiendo a los usuarios definir nuevos lenguajes de representación del conocimiento (que podrían estar muy cerca de los lenguajes naturales), y haciendo que un conjunto cada vez mayor de documentos se vuelvan más comprensibles para la máquina (sin hablar del constante crecimiento en número de documentos) TML y el Internet de lenguajes admitirán de forma amplia más tipos de lenguaje que la simple representación del conocimiento, pero eso sería suficiente por ahora.</p>
                <p>En esta publicación destacamos más la parte superior de la pirámide y menos su parte inferior, a diferencia de la publicación anterior. Espero que haya sido útil de alguna manera. ¡Gracias por leer!</p>


 
- title: La nueva Tau
  link: the-new-tau
  id: 1
  order: 3
  key: main
  author: Ohad Asor
  date: Publicado el 30/12/2017, 3:27 PM
  content: Estamos interesados en un proceso en el cual un grupo pequeño o muy grande de personas alcance y siga repetidamente los acuerdos. Nos referimos a procesos tales como la elección social. Identificamos cinco aspectos que surgen de ellos&#58; lenguaje, conocimiento, discusión, colaboración y elección sobre la elección. Proponemos un mecanismo de elección social mediante una cuidadosa consideración de estos aspectos.
  main_content: <p>Estamos interesados en un proceso en el cual un grupo pequeño o muy grande de personas alcance y siga repetidamente los acuerdos. Nos referimos a procesos tales como la elección social. Identificamos cinco aspectos que surgen de ellos&#58; lenguaje, conocimiento, discusión, colaboración y elección sobre la elección. Proponemos un mecanismo de elección social mediante una cuidadosa consideración de estos aspectos.</p>
                <p>Algunos de los principales problemas con la toma de decisiones de forma conjunta tienen que ver con escalas y límites que afectan el flujo y el procesamiento de la información. Se cree que esos límites son inherentes a la realidad, de tal manera que, en general, no se los considera superados. Por ejemplo, consideremos el caso en el que todos tienen derecho a votar, pero ¿qué pasa con el caso en el que todos tienen el mismo derecho a proponer qué votar?</p>
                <p>En grupos pequeños y en el día a día, generalmente no votamos, sino que expresamos nuestras opiniones, a veces las discutimos, y el resultado final ya sea acuerdo o desacuerdo u opiniones surge de la propia situación. Pero en comunidades grandes, como en un país, es normal pensar que todos tengan derecho a votar un número limitado de propuestas. Llegamos a esas pocas propuestas utilizando procesos jerárquicos (más bien descentralizados), en el mejor de los casos, dónde todos tienen derecho a proponer, pero cuyas opiniones fluyen a través de ciertos canales y alcanzan la fase de votación casi vacías, debido a la vasta información recopilada en el proceso. Sin embargo, ni siquiera nos atrevemos a imaginar que exista un derecho que consista en poder proponer qué votar de la misma manera que existe el derecho de voto, pensando siempre que pueda funcionar. De hecho, ¿cómo puede funcionar eso?, ¿cómo puede un votante superar un millón de propuestas cada día?</p>
                <p>Todos los métodos conocidos de discusión hasta ahora sufren de escalas muy pobres. Dos veces más participantes rara vez duplican la ganancia de información, y cuando el grupo es demasiado grande (incluso algunas docenas), el doble de participantes puede incluso reducir la ganancia total a la mitad o menos, y no mejorarla dos veces.</p>
                <p>Resulta que bajo ciertas suposiciones podemos alcanzar discusiones de escalado y flujo de información verdaderamente eficientes, donde 10,000 personas son 100 veces más efectivas que 100 personas, en términos de toma de decisiones colaborativas y formación de teoría colaborativa. Pero para esto necesitaremos la ayuda de las máquinas, y también necesitaremos ayudarlas para que puedan ayudarnos.</p>
                <p>Específicamente, no hay otro remedio que usar ciertos lenguajes, que pueden evolucionar con el tiempo y, por ende, permitir que las computadoras puedan entender de qué hablamos, para comprender las cosas dichas durante las discusiones. Como nadie sabe cómo hacer que las computadoras entiendan los lenguajes naturales, tendremos que dar un paso hacia las máquinas y usar lenguajes comprensibles para las máquinas. Vamos a detallar más sobre este punto, pero antes vamos a hablar un poco acerca de la auto-enmienda.</p>
                <p>Describimos una red informática descentralizada, Tau Chain, y como tal, ¿qué decisiones sociales puede apoyar? Lo máximo que las computadoras pueden hacer es ejecutar programas. Sobre Tau Chain podemos reunir conocimiento y estar de acuerdo o en desacuerdo sobre él, y también podemos generar algo y realizar acciones según surja de la discusión sobre la plataforma. Esas acciones, no son más que programas de computadora. Y el programa más importante en nuestro alcance es la plataforma en sí misma.</p>
                <p>Las principales elecciones en colaboración se realizan sobre el sistema, son sobre el sistema en sí. Tau, es una discusión sobre Tau. O en una definición un poco más elaborada pero sucinta:</p>
                <p style="padding:0 10%" class="text-center"><b>Considere un proceso, denotado por X, de personas, formando y siguiendo otro proceso denotado por Y. Tau es el caso donde X = Y.</b></p>
                <p>Eso es el Tau. No importa lo que sea Tau, lo que importa es que puede transformarse en lo que queremos que sea. Además, Tau es un programa de computadora, por lo que nos referimos a un programa que se adapta a las opiniones y decisiones colaborativas de sus usuarios.</p>
                <p>Cabe señalar que no permitimos que Tau adivine la opinión de la gente, ni siquiera que realice conjeturas como en el aprendizaje automático, y esa, quizás sea la razón principal por la que utilizamos la lógica. Las cosas que se dicen sobre la plataforma son tan formales y definidas como los programas de computadora, ya que solo tratan con conocimiento genérico y no con instrucciones de la máquina.</p>
                <p>Al tener eso, un programa de autorreferencia en colaboración, puede transformarse virtualmente en cualquier programa que queramos, o incluso, en muchos programas a la vez. De hecho, Tau no solo habla de sí mismo, sino que está abierto a la creación de cualquier otra actividad individual o en colaboración, de modo que los grupos pequeños y grandes puedan debatir, compartir y organizar el conocimiento, detectar el consenso y los desacuerdos, y coordinar acciones en forma de programas.</p>
                <p>Los cinco aspectos sociales mencionados al principio corresponden a la hoja de ruta de Tau. Aquí hay un breve resumen que se enfatizará más en el resto de esta publicación&#58; La implementación de TML y el Internet de lenguajes es el primer paso. Luego viene el Alfa, que es una plataforma de discusión. Luego, la versión Beta, que trata de seguir procesos de forma colaborativa (no solo definirlos), específicamente, se trata no solo de conocimiento sino también de programas. Alfa y Beta no están totalmente descentralizados en su infraestructura como en Bitcoin. Posteriormente, y con la ayuda de Alfa y Beta, llega Tau, que es una plataforma descentralizada de elección social auto-enmendada. Además de eso, tendremos un mercado de conocimiento que es uno de los tres componentes de Agoras (los otros dos son&#58; los mercados de recursos computacionales como Zennet y una economía de nuevo diseño que ofrece características como interés sin riesgo sin necesidad de imprimir dinero nuevo, implementando un mercado de derivados).</p>
                <p>Para que las máquinas potencien nuestra capacidad de discusión y colaboración, deben tener acceso al significado de lo que decimos. Las máquinas usan ciertos tipos de lenguajes mientras que los humanos usan diferentes tipos. Hacer que las máquinas utilicen lenguajes humanos, es algo que nadie sabe cómo hacer y, para los seres humanos, utilizar directamente lenguajes de máquina es un inconveniente en la medida en que simplemente no se ajusta a la comunicación humana común de intercambio de conocimiento&#58; los lenguajes de máquina están hechos de instrucciones de la máquina, mientras que la representación del conocimiento es de una naturaleza diferente. En otras palabras, las máquinas esperan información operacional, mientras que los humanos hacen un gran uso del lenguaje declarativo. De hecho, uno de los objetivos de Tau es dejar que podamos centrarnos en el "saber-qué" y dejar que las máquinas descubran el "saber-cómo".</p>
                <p>Por lo tanto, presentamos una posición ampliamente sugerida anteriormente (por ejemplo, el artículo "Representación del conocimiento y lógica clásica" de Lifschitz et al) que se coloca en el medio entre los lenguajes humanos y el de la máquina, que es la lógica. La lógica formal es en gran medida natural para los humanos y es algo con lo que las máquinas pueden trabajar. Pero, aún así, la "lógica formal" no es nada particular, ya que no apunta a ningún lenguaje, sino que es una vaga descripción de una familia de lenguajes.</p>
                <p>Postulamos que no debe y no puede haber un solo lenguaje universal. No hay ninguna razón para que un lenguaje sea óptimo (o incluso adecuado) para todas las necesidades. Por lo tanto, se nos ocurre un metalenguaje que es capaz de definir nuevos lenguajes, pero, esto sería volver al principio con un [meta-]lenguaje universal. Por lo tanto, necesitamos que el metalenguaje se redefina y cambie, al igual que puede definir otros lenguajes. Con esto, obtenemos no solo muchos lenguajes, sino también un lenguaje que se modifica a sí mismo, que es una parte importante de un sistema de auto-enmienda.</p>
                <p>Resulta que las lógicas que pueden definirse a sí mismas y tener buenas propiedades lógicas, como la decidibilidad, no son muy comunes. Tenemos máquinas universales de Turing, pero un lenguaje menos expresivo y más informativo (por ejemplo, decidible) no es fácil de encontrar. Adoptamos la lógica PFP cuya expresividad es PSPACE-completa, como se conoce en los libros de teoría de modelos finitos, y se demostró que es capaz de definirse en el libro de Imhof, 1999 "Lógicas que definen su propia semántica".</p>
                <p>Desde aquí continuamos a Internet de lenguajes. Usando el metalenguaje que llamamos TML (Tau Meta-Lenguaje, puede obtener información del trabajo continuo en github), los usuarios definen nuevos lenguajes especificando fórmulas lógicas para describir lo que significa que dos documentos en diferentes lenguajes tengan el mismo significado. En otras palabras, para definir un nuevo lenguaje, uno necesita definir cómo se genera una traducción que preserva la semántica en un lenguaje existente. La semántica, en nuestro alcance, es ontológica (objetos y relaciones), y no semántica operacional como en los lenguajes de programación. Con esto obtenemos un Internet de lenguajes de representación del conocimiento que hace que la elección del lenguaje no importe. Un documento en un lenguaje se puede transformar (usando programas TML) a diferentes lenguajes.</p>
                <p>No nos referimos a la traducción como del francés al chino, ya que ya hemos insistido en que no tratamos con los lenguajes naturales. Por supuesto, teóricamente, podría darse el caso de que algún día alguien programe sobre TML algo que pueda entender completamente el lenguaje natural, pero no contamos con tal evento. De hecho, hay muchos formalismos de lenguaje natural que son bastante cercanos al lenguaje completo y con los que los humanos pueden trabajar (lo que llamamos "inglés lo suficientemente simple que hasta las máquinas lo pueden entender"), por lo que podemos esperar que TML procese lenguajes comprensibles para el ser humano hasta cierto punto. Pero TML está destinado también para lenguajes de máquina únicamente. Por ejemplo, uno podría querer convertir un documento a un formato HTML o en un Wiki, o convertir un programa en algún lenguaje de alto nivel a código de máquina, o también sintetizar el código de la lógica.</p>
                <p>De manera más general, TML pretende ser un compilador-compilador. Para ser tan eficiente y no tener que considerar la lógica de los lenguajes una y otra vez con cada compilación de documentos escritos en ella, adoptamos el enfoque de evaluación parcial, que da lugar a características adicionales muy deseables para un compilador-compilador, en forma de proyecciones de Futamura.</p>
                <p>Ahora que podemos expresar conocimiento y opiniones en varios lenguajes (precisamente aquellos lenguajes que los usuarios definen a través del Internet de lenguajes a lo largo del tiempo), podemos comunicarnos usando esos lenguajes. Consideramos la comunicación Humano-Humano, o más específicamente la comunicación Humano-Máquina-Humano. La máquina no es una parte igual en la conversación, es solo una máquina, solo organiza lo que decimos y, puede hacerlo, ya que codificamos nuestra información de una manera accesible para ella. Un usuario puede transmitir una idea a otro usuario, y en este estrecho ámbito de transmisión de una idea entre dos personas, ya podemos disfrutar de tres beneficios&#58; fácil explicación, fácil comprensión y formalización del conocimiento como un subproducto.</p>
                <p>Específicamente, quien expone no necesita hacer que el otro usuario lo entienda, solo necesitan que la máquina lo entienda. Esta tarea puede ser más simple en algunos aspectos y más compleja en otros, aún y así las máquinas están ciertamente menos ligadas a la organización y la escala que los humanos. Habiendo logrado una idea formalizada en un lenguaje comprensible por la máquina, el segundo usuario ahora no solo puede traducirlo a otros lenguajes de representación del conocimiento u organizarlo como lo considere conveniente o compararlo con otras ideas formalizadas, sino que también puede formularle preguntas a la máquina. Dado que la máquina entendió completamente el tema, y por entendido, nos referimos a la capacidad teórica de responder todas las preguntas (la decidibilidad surge nuevamente aquí), puede ayudar al usuario a entender por la misma definición de comprensión, ya que puede responder todas las preguntas del usuario, sin la necesidad de remitir la pregunta al autor de la idea original.</p>
                <p>Pero Alfa va más allá de ese caso. Alfa es sobre discusiones de cualquier escala. Está estructurado como discusiones al igual que en foros o redes sociales, con publicaciones y comentarios, que pueden aparecer en un equipo o un perfil. Un perfil (o identidad) es un lugar donde las personas suelen publicar sus opiniones personales, y podrán compartirlas con otros perfiles con los que están conectados. Un equipo es un grupo de identidades, creado y configurado por algún usuario, y destinado a tratar un tema determinado. Por ejemplo, un equipo podría desarrollar colaborativamente un producto de software, o redactar una ley o contrato acordado, o simplemente cualquier idea científica / filosófica / social / sin sentido.</p>
                <p>Hasta ahora suena como cualquier otra plataforma de discusión, pero aquí podemos tener muchas más características gracias al uso de lenguajes comprensibles por la máquina. Para enumerar algunos&#58; detectar automáticamente los argumentos repetidos por la misma persona, o recopilar lo que cada persona dijo durante la discusión y mapear todos los puntos de acuerdo y desacuerdo, o enumerar todas las opiniones y luego quién está de acuerdo con ellas (personas por opinión en lugar de opiniones por persona), o para organizar la información puesta en la discusión de forma más organizada y legibles como una wiki. Incluso puede hacer comentarios automáticamente&#58; supongamos que ve una publicación de alguien que expresa una opinión, pero ya ha expresado en profundidad su opinión sobre el tema en el pasado. Luego puede hacer clic en "auto-comentar" y el sistema expresará automáticamente su opinión, en función de la información exacta que proporcionó en el pasado y en relación con la publicación que está auto-comentando. O, lo que quizás es más importante, para calcular el conjunto de declaraciones acordadas por todos sin excepción, en algún ámbito, puede ser de toda la red, por equipo, o por perfiles conectados a mi perfil, por discusión, etc. Recuerde, esto no es una magia en absoluto, una vez que todo está escrito en lógica (o dado que tenemos una lógica que puede traducirlo a la lógica, es decir, las definiciones TML de los lenguajes de los documentos).</p>
                <p>Sobre Alfa, le enseñamos a la red mucho conocimiento, intencionalmente o como un subproducto de las discusiones. También formamos teorías en las que estamos de acuerdo y todos contribuimos. ¿Qué podemos hacer con este conocimiento? En última instancia, en el mundo de la informática, todo lo que podemos hacer es ejecutar programas de computadora. En Beta podremos analizar programas y luego ejecutarlos. En Tau, tendremos un equipo especial llamado Tau, de modo que cada vez que el grupo acepte una nueva decisión, el código de Tau se modifique automáticamente. Sobre la versión Beta podremos hacer realidad esas cosas que acordamos como deseables en Alfa, en nuestras discusiones. Una vez que un equipo acuerda o modifica su acuerdo sobre una especificación de algún programa, no es necesario escribir ni reescribir ningún código, ya que puede hacerse de manera automática, ya que todo está disponible en un lenguaje comprensible para la máquina. Sintetizar el código a partir de las especificaciones es otra traducción del lenguaje que se realizará a través de Internet de lenguajes, pero, por supuesto, se deben desarrollar transformadores de lenguaje adecuados para permitirlo. Este es un buen ejemplo de cosas que son más fáciles de decir que de hacer, y los detalles son altamente técnicos. Es suficiente mencionar que las capacidades de síntesis de vanguardia aparecen en el mundo MSO + λY.</p>
                <p>La elección sobre la elección es elegir cómo elegir. Poder cambiar el mecanismo de elección en sí mismo, o, en otras palabras, las normas para cambiar las normas, o lo que es lo mismo, para cambiar el código de Tau con el tiempo. Esto en sí mismo plantea paradojas y limitaciones a las lógicas posibles. Si las reglas pueden cambiar por sí mismas, inevitablemente se contradicen a sí mismas cuando intentan decir algo más. ¿Cómo podemos formalizar tal proceso de una manera libre de paradojas? Uno puede ser engañado a identificar normas sobre normas y decisiones sobre decisiones con una lógica de orden superior, pero esto no es suficiente. Considere, por ejemplo, la norma "todas las normas, incluido esta, pueden modificarse solo por mayoría". Como esta norma también opera sobre sí misma, no tiene un orden finito. Por lo tanto, necesitamos la recurrencia para tratar las normas que cambian las normas. Este es un aspecto importante involucrado en la elección de la lógica de punto fijo para TML y el cálculo λY en la Beta (a propósito, Bauer mostró en "Sobre los auto-interpretadores para el sistema T y otros tipos de cálculos λ) que un lenguaje puede auto-interpretarse si tiene un punto fijo, lo que excluye el total de lenguajes de programación).</p>
                <p>Un enfoque para el cambio de normas que se consideró en el viejo Tau es el enfoque de Nomic. Para explicar el enfoque de Nomic y el nuevo enfoque de Tau, utilizaremos un ejemplo. Considere la posibilidad de que dos abogados representen cada uno de los dos lados de un trato e intenten converger en un contrato en el que ambos abogados estén de acuerdo. Una forma sería la siguiente. El primer abogado sugiere una cláusula en el contrato, y el segundo abogado puede estar de acuerdo o no. Si se acuerda, entonces la cláusula se adjunta, de lo contrario, no. Entonces, es el turno del segundo abogado para proponer una cláusula, etc. Esta sería la forma Nomic. El equivalente para Tau es aplicar parches de código sucesivos con el tiempo. Al hacer eso, planteamos una asimetría entre las opiniones que llegaron primero. Hay mucho que decir sobre esta asimetría y cómo Tau logra evitarla casi por completo, pero por ahora, considere el caso en el que una cláusula recientemente propuesta contradice una antigua cláusula. Si no queremos dar prioridad a lo que vino primero, entonces hay que modificar la cláusula nueva o la antigua o incluso tener que modificar otras cláusulas, y no eliminar por defecto la cláusula antigua.</p>
                <p>Otra forma, sería que, en cada turno, cada abogado envíe un borrador completo del contrato, y el otro abogado pueda aceptarlo o proponer un borrador diferente. Al requerir que cada borrador sea lógicamente consistente, nunca tendremos que lidiar con las contradicciones entre el pasado y el futuro. Elimina por completo la necesidad de mirar hacia atrás. Pero todavía no puede escalar. ¿Qué pasaría si tuviéramos un millón de abogados, leerían un millón de borradores?</p>
                <p>Sobre Tau podemos tomar todos esos millones de borradores de contrato, que corresponden a las propuestas del siguiente código completo de Tau, y de una manera bastante directa (gracias al formalismo lógico de los documentos) calcular el núcleo preciso en el que todos están de acuerdo, y enumerar los puntos a resolver No necesitamos votar, lo hacemos como en pequeños grupos en la vida real&#58; simplemente hablamos, y el mapa de opiniones surge de la conversación para cualquier oyente inteligente.</p>
                <p>Hay mucho más que decir, y se mencionará en más publicaciones del blog y otras publicaciones, pero eso es todo por ahora. Estaré más que feliz por leer sus opiniones y enfoques con respecto a los temas mencionados, especialmente la elección social práctica y cómo hacer escalar las discusiones.</p>


- title: Tau y la crisis de la verdad
  link: tau-and-the-crisis-of-truth
  id: 2
  order: 4
  key: main
  author: Ohad Asor
  date: Publicado el 10 de septiembre de 2016, a las 11:25 
  content: Vivimos en un mundo en el que nadie conoce la ley. Excepto casos triviales, no se puede saber qué es legal y qué no, todo lo que se puede hacer es probar y ver cuál es la opinión del juez o del policía después de haber tomado tus acciones, dichas opiniones por supuesto difieren la una de la otra. O, puede consultar a un abogado que le dirá que no hay respuestas absolutas y, a fin de cuentas, es una cuestión de probabilidad que desafortunadamente nadie sabe cómo calcular
  main_content: <p>Vivimos en un mundo en el que nadie conoce la ley. Excepto casos triviales, no se puede saber qué es legal y qué no, todo lo que se puede hacer es probar y ver cuál es la opinión del juez o del policía después de haber tomado tus acciones, dichas opiniones por supuesto difieren la una de la otra. O, puede consultar a un abogado que le dirá que no hay respuestas absolutas y, a fin de cuentas, es una cuestión de probabilidad que desafortunadamente nadie sabe cómo calcular. Puede hacer su mejor esfuerzo para tener una vida productiva y seguir las reglas tal como las entiende o como lo guían los abogados, pero nadie puede garantizar que no será considerado un delincuente, o que no se tomarán acciones legales en su contra. Del mismo modo, uno puede vivir una vida haciendo daño a muchas personas y ningún sistema legal lo detendrá, incluso si el sistema es consciente de las medidas adoptadas. Tal situación pesimista no es nueva y no es local, y para mi gusto fue mejor descrita por Franz Kafka.</p>
                <p>El jugar con las palabras y llevarlas a cualquier contexto deseado, conscientemente o no, con buenas o malas intenciones, siempre estuvo ahí desde que la humanidad aprendió a hablar. Las peores mentiras solo contienen verdades y los peores crímenes tienen licencia, además se pueden presentar argumentos para justificar casi cualquier cosa. Esta "crisis de la verdad" es la base de la corriente postmoderna de la filosofía, especialmente el enfoque <a href="https://es.wikipedia.org/wiki/Deconstrucci%C3%B3n" target="_blank">deconstructivista</a> que demuestra cómo los textos pueden interpretarse de muchas maneras (contradictorias). "No hay una sola verdad" es la base del postmodernismo. Pero, ¿podemos al menos tener algún terreno de verdad en la que los contratos sociales pueden ser útiles y tener sentido?</p>
                <p>No solo las leyes no se pueden entender de una manera absoluta, sino que ni siquiera se pueden hacer trivialmente mediante un proceso absoluto. Las leyes tienen que cambiarse con el tiempo y, por lo tanto, también necesitamos leyes para cambiar las leyes. Pero luego necesitaremos leyes para cambiar las leyes, para cambiar las leyes, ad infinitum. Por lo tanto, permanecemos sin ninguna base lógica para el proceso de reglamentación, no solo la crisis de decidir qué es legal y qué es ilegal. Esta paradoja fue descrita en el libro disponible en línea <a href="http://legacy.earlham.edu/~peters/writing/psa/index.htm" target="_blank">La paradoja de la auto enmienda</a> de Peter Suber. La solución de Suber se resume en el apéndice de ese libro que describe el juego Nomic. Él ofrece un sistema de dos niveles en el que tenemos reglas mutables e inmutables, incluidas las reglas de transmutación de una regla (es decir, hacer que la regla inmutable sea mutable o viceversa). De esta manera uno puede evitar la jerarquía infinita de esquemas de enmienda, pero aún permanecemos con la "crisis de la verdad" en la que no hay una sola verdad, especialmente cuando la necesitamos desesperadamente, y a pesar del propósito mismo de las leyes para tener un cierto orden social en vez de desinformación y caos.</p>
                <p>Al retroceder desde el mundo de las legalidades y tratar de responder preguntas similares en el mundo de los números y los objetos matemáticos, la tarea no se vuelve fácil, pero podría decirse que es más fácil. Los lógicos han contemplado esas ideas durante siglos y se les ocurrió la noción de decibilidad. Un lenguaje es decidible si cada declaración expresable en un lenguaje puede decidirse si sigue las reglas expresadas en ese lenguaje. Un ejemplo asombroso sería el teorema de Godel&#58; si nuestro lenguaje es capaz de expresar la <a href="https://es.wikipedia.org/wiki/Axiomas_de_Peano" target="_blank">aritmética de Peano</a>, es decir, contiene los números naturales 1,2,3, ... equipados con suma y multiplicación y sus reglas (que de hecho los determinan de manera única), entonces siempre habrá algunas afirmaciones verdaderas sobre la aritmética de Peano que no pueden probarse a partir de las definiciones. Por ende, se necesitan infinitos axiomas para poder decidir la corrección de cada enunciado. Un ejemplo de decidibilidad sería la <a href="https://en.wikipedia.org/wiki/Presburger_arithmetic" target="_blank">aritmética de Presburger&#58;</a> si abandonamos la multiplicación y definimos los números solo con suma (de cierta manera), volvemos a la decidibilidad y cada afirmación podría decidirse en un proceso finito como verdadera o falsa. Lo mismo se aplica a la geometría Euclides de 2000 años de antigüedad, que es una teoría decidible.</p>
                <p>Por lo tanto, estamos interesados en crear un proceso social en el que expresemos las leyes solo en un lenguaje decidible y colaborativamente formemos contratos sociales modificables sin caer en paradojas. De esto se trata Tau-Chain.</p>
                <p>Esta larga introducción sirve para enfatizar la importancia y el papel central de la decidibilidad en general en la vida y específicamente en Tau. Si queremos que Tau haga una contribución real al mundo, debe usar un lenguaje decidible. El diseño inicial de Tau pretendía responder a esos requisitos, pero recientemente descubrí que estaba equivocado, y el lenguaje elegido inicialmente es simplemente indecidible. <a href="https://en.wikipedia.org/wiki/Intuitionistic_type_theory" target="_blank">La teoría de tipos Martin-Lof</a> (MLTT) tiene solo ciertos aspectos decidibles (específicamente, la igualdad). Pero no es el caso que todo lo expresable sea decidible. Esta situación me llevó a la conclusión de que MLTT era una elección incorrecta, y, por tanto, era necesario considerar otra lógica. De hecho, algunas declaraciones mías en algunos blogposts y videos fueron erróneas, ya que MLTT no tiene una comprobación de tipo decidible.</p>
                <p>MLTT trata de los llamados "tipos dependientes", de los que trataré de dar una pequeña muestra en este párrafo. Tenemos "términos" y "tipos". Puede ver términos como declaraciones y tipos como especificaciones que esas declaraciones deben cumplir. ¿Cómo de general pueden ser las especificaciones? Los tipos dependientes vienen a darles máxima expresividad en cierto sentido&#58; los tipos pueden depender de los términos, y los términos pueden depender de los tipos (y de ahí viene el nombre "tipos dependientes"). Podemos expresar cualquier especificación que nuestro lenguaje de términos pueda expresar, o más exactamente, los tipos pueden ser establecidos por un programa que los calcule, que pueden depender de otras partes del código. Los programas pueden incluir especificaciones y las especificaciones pueden incluir programas. Typecheck es el proceso de asegurarse de que los términos cumplan con sus tipos. Pero si los tipos pueden ser programas genéricos, tenemos que exigir que se ejecuten y devuelvan un resultado en un tiempo finito. Para eso tendremos que asegurarnos de que nuestros programas se detengan, por lo que hemos alcanzado <a href="https://es.wikipedia.org/wiki/Problema_de_la_parada" target="_blank">el problema de la parada</a>. Solo si puede afirmar que sus tipos se calculan en un proceso finito, entonces el proceso mismo del comprobador se vuelve decidible. Pero esta tarea es indecidible por sí misma ya que el problema de la parada es indecidible. Entonces, si quieres llegar a la decidibilidad sobre los tipos dependientes, primero hay que pasar una barrera indecidible de la parada. Esto es posible en muchos casos, ya que muchos programas pueden escribirse en una forma que probablemente termine (por ejemplo, la <a href="https://es.wikipedia.org/wiki/Recursi%C3%B3n_primitiva" target="_blank">recursión primitiva</a> que es la base de la <a href="https://en.wikipedia.org/wiki/Total_functional_programming" target="_blank">programación funcional total)</a>, pero es inherentemente imposible encontrar un método para todos los programas, de lo contrario, el problema de la parada sería decidible.</p>
                <p>Los lenguajes de tipo dependiente se usan ampliamente en el mundo de las pruebas asistidas por computadora y la verificación formal, pero tienen la reputación de ser difíciles de trabajar. La dificultad proviene no solo de que su teoría es significativamente más complicada que la de otros lenguajes, sino que la parte más difícil es convencer al contador de tipos (o comprobador de terminación y totalidad intenta asegurar que el proceso de verificación de tipo sea finito) de que su código cumpla con sus especificaciones. Por lo tanto, el proceso de verificación de tipo no es automático y requiere una cantidad significativa de intervención humana solo para convencerlo de que acepte declaraciones verdaderas, una dificultad que surge exactamente de la indecidibilidad del lenguaje. Posteriormente perdemos la capacidad de determinar siempre y de forma totalmente automática si una oración es verdadera, o equivalentemente, si alguna acción (término) es legal (bien tipado) o ilegal de acuerdo con las reglas dadas.</p>
                <p>El remedio para esta situación es escoger una lógica diferente, una lógica "completa". Una lógica completa significa que todo es decidible, y no solo ciertos aspectos de la misma (como la igualdad en MLTT). Godel demostró que cada lógica que se completa y es capaz de expresar la aritmética de Peano inevitablemente será inconsistente, por lo que para disfrutar de consistencia y completitud tendremos que renunciar a una parte de la aritmética. No solo se conocen lógicas completas y consistentes que podemos usar, sino que recientemente se descubrió que estas familias de idiomas son mucho más expresivas de lo que se sabía anteriormente. Específicamente, ciertas clases de Lógica de Segundo Orden de Monadic (MSO o MSOL) fueron completas y constantes desde la década de 1960, pero no tenían habilidades expresivas satisfactorias. No fue sino hasta 2006 que Luke Ong <a href="https://www.cs.ox.ac.uk/people/luke.ong/personal/publications/lics06.pdf" target="_blank">presentó</a> una prueba de integridad de MSOL sobre los llamados "Esquemas de recursión de orden superior", que es un lenguaje funcional de orden superior de tipo simple (más bien dependiente) con recursión, que mejoró drásticamente la expresividad de lenguajes conocidos como completamente decidibles. Desde entonces, se hicieron avances tanto en la teoría como en la práctica, especialmente por <a href="http://www-kb.is.s.u-tokyo.ac.jp/~koba/" target="_blank">Naoki Kobayashi</a>.</p>
                <p>Fue un largo viaje hasta que descubrí que mis premisas básicas estaban equivocadas y, de hecho, no era un lógico (persona que se dedica al estudio de la lógica) cuando comencé el viaje. Afortunadamente ahora podemos modificar el diseño de Tau en algo que es incluso mejor de lo que pensábamos antes, incluso si MLTT fuese decidible. Mencionar tres ventajas&#58; la existencia de un modelo computacional directo, la capacidad de inferir programas y la simplicidad de uso.</p>
                <p>Las teorías de MSO tienen un modelo computacional directo en términos de autómatas. Las fórmulas de MSO se pueden traducir en máquinas redundantes que leen una declaración y deciden si cumple con la fórmula. Además, esos autómatas se pueden minimizar de una manera única, por lo que obtenemos un código potencialmente óptimo. Por otro lado, MLTT no disfruta de una traducción directa a autómatas, sino que más bien la conexión lógica-autómata admite un concepto más general de programas como pruebas, donde el proceso de prueba se deja más vagamente especificado en términos computacionales y una traducción directa a autómatas no existe. No puede existir, ya que los autómatas son un procedimiento explícito de decisión finita, mientras que los tipos dependientes no son completamente decidibles.</p>
                <p>La segunda ventaja notable es la programación automática, más comúnmente llamada "síntesis de programa" en la literatura. Si damos una especificación de un programa (o base de reglas), ¿puede la máquina calcular el programa (o las reglas) por sí misma? Esta tarea es indecidible en MLTT, pero en una lógica completa es posible. Podemos tener programas y contratos correctos por construcción, simplemente indicando lo que esperamos que hagan, y ordenando a la máquina que encuentre una estructura que admita nuestros requisitos.</p>
                <p>La lógica MSO es más fácil de usar por las razones mencionadas anteriormente&#58; es un lenguaje más simple, y no requiere intervención humana para convencer que una declaración verdadera es verdadera. También representa una lógica más intuitiva&#58; MLTT es una lógica <a  target="_blank" href="https://es.wikipedia.org/wiki/Intuicionismo">intuicionista</a> que significa que una afirmación que resultó ser falsa no implica necesariamente que su contraste sea verdadero. Por ejemplo, uno no siempre puede usar una prueba por contradicción. La lógica intuitiva permite probar la inexistencia por contradicción&#58; puede suponerse que algo existe, derivar una contradicción y, por lo tanto, concluir que no existe. Pero no puede sustentar una demostración por contradicción de la no existencia&#58; asumir que algo no existe y derivar una contradicción no prueba que exista, bajo lógica intuicionista. Más formalmente, la lógica intuicionista niega explícitamente <a target="_blank" href="https://es.wikipedia.org/wiki/Principio_del_tercero_excluido">la ley del tercero excluido</a>. Y esto, por supuesto, es muy poco intuitivo y permite la posibilidad de errores humanos, especialmente en estructuras complicadas. Por otro lado, MSO es una lógica clásica, significa que incluye la ley del tercero excluido&#58; es simplemente imposible que cualquier cosa sea verdadera y falsa al mismo tiempo. El tercero está completamente excluido, mientras que, si agregamos esta regla a MLTT, pierde su consistencia.</p>
                <p>Como conclusión, nuestro viaje resultó ser diferente de lo que esperábamos desde el aspecto de la implementación, pero terminará con un mejor producto que nos dará la oportunidad de resolver la crisis de la verdad y la paradoja de la auto-enmienda en un contexto global, social y electrónico. Personalmente tengo la intención (y prometí) de seguir trabajando a tiempo completo hasta cumplir con Tau y Agoras que introducirán muchas más características de las que se describen aquí. Recientemente <a target="_blank" href="https://www.youtube.com/watch?v=TKhzo_60f6Y">grabé una descripción condensada</a> de los productos que me he comprometido a entregar. Otro artículo y otro video están en camino para explicar más detalles. Si está dispuesto a ayudar a lograr estos objetivos y se encuentra a usted mismo (o a su amigo) comprendiendo los documentos de Kobayashi, estaré encantado de cooperar.</p>

- title: "Project Roadmap"
  link: project-roadmap
  key: archive
  id: 3
  order: 5
  author: Ohad Asor
  date: Apr 9, 2016
  content: Tau is a language. It is a programming language, but not only such. It may express virtually any arbitrary knowledge, rules, and processes. Examples are contracts, mathematical proofs, scientific facts and arguments, and legal documents.
  main_content: <p>Beginning with some recap:</p>
                <p>Tau My Life&#58; A Memoir is a language. It is a programming language, but not only such. It may express virtually any arbitrary knowledge, rules, and processes. Examples are contracts, mathematical proofs, scientific facts and arguments, and legal documents. Its power comes from being unambiguous and consistent while still maintaining maximum (finite) expressibility. A more detailed explanation of what consistently decidable means and why it is the strongest Tau's property has a dedicated explanation on the following short talk:</p>
                <p class="text-center width-100 margin-auto"><iframe width="480" height="270" src="https://www.youtube.com/embed/Utggm7cuGbo"></iframe></p>
                <p>This isn't new, this type of language (specifically, Martin-Lof Type Theory [MLTT]) has known implementations. Tau's innovation is by adding DHT and Blockchain primitives to the language, and by that make the language aware of other peers and be able to coordinate with them securely and meaningfully. Another innovation is adapting the RDF language family to MLTT, taking the subject-verb-object format of the famous RDF languages family (e.g. Notation3) and giving it MLTT logic, makes Tau a more accessible, readable, and portable language than other MLTT implementations.</p>
                <p>What we develop now is a compiler to this language, means, something that takes a document written in Tau language together with a query about that document, and resolves the query. But there's another important building block which is shared knowledge and rules.</p>
                <p>The languages incorporate a shared level expressed by the built-in blockchain. Tau-Chain is designed to have a single root chain. This chain contains code, written in Tau language, and this code is being executed. As a metaphor, imagine a piece of code that all it is doing is to download itself from github and execute it, again and again, while the code might be changed and do additional operations in the meanwhile. A Tau client downloads its own code from the root chain, it downloads a block, executes the code in it, and this code instructs how to download and run the next block. By that, the client understands the blockchain according to the network rules that were relevant at that point of time when the block was created. This gives rise to the network being self-defining. Tau begins its genesis block clean of rules, and the rules of the network will then be determined collaboratively over the network by the first users.</p>
                <p>To get a glimpse of what uses such a network gives rise to, see this blogpost. For an description of Tau as a generalized blockchain, see here.  Tau also incorporates the lambda-auth design for verifiable computing, as described here.</p>
                <p>A more detailed use case appears here and is summarized on the following short video:</p>
                <p class="text-center width-100 margin-auto"><iframe width="480" height="270" src="https://www.youtube.com/embed/1SXfYgQxsOA"></iframe></p>
                <p>Many of those use cases are to be built on Agoras. Specifically, we plan to implement over Agoras the code-for-money market, computational resources market (as on Zennet's vision), and a decentralized smart search engine (aiming to obsolete Google), among some other plans. Those require a currency, and Agoras will be a currency implemented using Tau's architecture, inheriting the self-definition and democracy abilities, protocol elasticity, and smart yet comprehensible contracts.</p>
                <p>Tau as for itself comes with no coin and begins completely and inherently equal. It is merely a language with a blockchain, but with far reaching consequences. It is meant to be a platform for decentralized (and offline) applications. Agoras will be only one of them. Tau is designed to leave no incentive to others not to develop over it, e.g. due to its code reuse abilities and the incentive to combine hashes to one root chain, to mention only two aspects.</p>
                <p>The selected mentioned markets that Agoras is planned to implement need abilities that are unique to Tau, and, they give unrefusable answers to some of the most disturbing bottlenecks in the world economy, software development, computational resources, and data together with processing it. An example to additional idea to be implemented on Agoras but not fully developed yet, derivatives market that also implements risk-free interest (without printing new money!).</p>
                <p>Explaining Tau, Agoras, and their implications is not an easy task. We have been working on explanatory materials and had a significant success in spreading the word and the vision, yet this success in explaining the ideas is still very partial. The current materials still doesn't show the whole detailed picture, and are not clear enough. A new website and additional videos are currently under construction. More people are getting involved and trying to explain the ideas in their own words. This process takes time and work, but it is important that enough people will figure out what this is all about, as it is really about something big that has a fundamental impact on all aspects of life (and I understand if I didn't manage to convince you about this point yet). Its success strongly depends on how people understand it, because the users themselves are going to set the rules of the network. The larger the consensus and the more arguments are raised, the more chance to converge towards better rules. We don't have to worry about too much or too complicated information, that's why we have Tau.</p>
                <p>Having more people understanding the project is also important from the pre-sale point of view. We need to distribute the Agoras coins somehow, so we pre-sale them and by that we also hope to receive long-term funding to the projects. Agoras project will require much more effort and human resources than the Tau client if we wish to fulfill our vision in the optimal way. The coin distribution has to be fair at the sense that people were given a reasonable opportunity to understand what this project is really about. The above has to do with the sale going on longer time than usual in the cryptocurrency world, nevertheless the project is quite different than others, and has to be managed as a serious software startup and not according to common practices in the cryptocurrency world that might suite other types of projects.</p>
                <p>Still, early buyers have to be incentivized. We had a weekly 2% raise in price and recently suspended it. But from May 1 the price per token we sell at will be 20 cents, going up 5% monthly (recall it has nothing to do with prices people sell at on the exchange). Beginning from today we offer the following wholesale discount, every additional 10K tokens will give additional 5% discount. So if one purchases 30K tokens, the price for the first 10K is the regular price, then a 5% discount on the next 10K tokens, then 10% discount on the subsequent 10K tokens. All purchasers via email receive a tax invoice with their desired recipient name. A buyer that agrees not to receive the intermediate tokens but only the final coins gets additional 15% discount. The total marginal discount will never go below 50% (as to be fair with earlier buyers).</p>
                <p>This current stage is extremely preliminary, as the implications of the technology aren't even fully explained yet, and even the language itself isn't ready yet. When things will look like they really are, namely, that if it all works as planned then we offer unrefusable replacement to markets of literally dozens of trillions as for today, this will be well reflected in the market cap. Far to mention, when the final coins will take action together with the already implemented futuristic markets.</p>
                <p>For final words, your participation in thinking of the rules of changing the rules is very important. Please give some thoughts, ask questions and have discussions about how you'd like Tau to be like. If we do it right, it'll meaningfully master all mankind's knowledge and way beyond.</p>


- title: "Tau as a Generalized Blockchain"
  link: tau-as-a-generalized-blockchain
  key: archive
  id: 4
  order: 6
  author: Ohad Asor
  date: Oct 17, 2015
  content: Bitcoin may abstractly be described as a decentralized machine that appends new data (transactions) to a public shared database (ledger) given certain proofs (signatures).
  main_content: <p>Bitcoin may abstractly be described as a decentralized machine that appends new data (transactions) to a public shared database (ledger) given certain proofs (signatures).</p>
                <p>One immediately asks, what if we take the Blockchain algorithm and allow arbitrary data with multiple public shared databases and with arbitrary proofs? Moreover, can the protocol itself evolve with time? </p>
                <p>Let's break those questions into pieces:</p>
                <p>1. Allowing arbitrary data, Bitcoin's protocol may already encode arbitrary data, but not efficiently. It costs way beyond customary storage networks or services, and the cost is justified – all nodes have to store and process that data.</p>
                <p>2. Multiple public shared databases we'd like to have many different applications over one Blockchain that secures them all, yet we don't want users of one application to be affected by the existence of another application.</p>
                <p>3. Arbitrary proofs, proofs are nothing but computer programs and vice versa. At Bitcoin's scope, the proof is the signature verification function's output, sometimes with addition of scripts (examples of useful scripts at https://en.bitcoin.it/wiki/Contract), yet Bitcoin's scripts are quite weak. So we'd like to allow arbitrary code to “run on the blockchain”, a code that is able to do practically anything that a computer can do.</p>
                <p>4. Self-definition, Since we speak of a shared database of programs, can the network's protocol itself, i.e. the client's code itself, be on-chain and auto-update itself from the chain?</p>
                <p style="margin-top:25px">1 is a special case of 3 since ultimately code can contain data (and that's basically Ethereum, Bitcoin+3). 2 can be achieved by allowing to put many programs on the blockchain, while users pick which program to run. This can be fulfilled by a blockchain containing Java/C++/Python/Precompiled programs, in other words, a decentralized appstore that auto-updates its own code (4). We call this construction Naive Tau.</p>
                <p>Why is it naive? Because apparently it answers all requirements, but de-facto we didn't decentralize anything, the code itself still comes from centralized hands. Since we have to either trust the program's developers for its safety or for other guarantees, we can no longer expect users to trust all programs on the network or a subnetwork. That, even if executing the program is required in order to validate a financial transaction and get into a public ledger. This is unlike, say, Bitcoin's blockchain, that transactions and scripts are “innocent” enough for everyone to safely publish or validate.</p>
                <p>A popular concern among projects dealing with trustless computing is the Halting problem. How can we know that execution of a given code will ever halt, rather stuck all machines on the network? It turns out that under a Turing Complete language, it is impossible to build a software that decides whether given source-code, its execution will ever halt. Ethereum confronted this problem with so-called Gas. The code is indeed executed among all machines participating in the network once they validate the blocks, but the code's author pays per how many computational steps the code has actually performed. If it performs too much calculations (“out of gas”), it is then aborted.</p>
                <p>Obviously, we would like to know much more than only whether a code is halting or not, but also its exact running time given some input, without the need to actually execute it. Similarly, we would like to have custom user-defined guarantees about code without executing it, like that it does not do insecure operations (by any well-defined measures of insecurity, such as connecting to the local network or accessing private files). We will also be very happy to know that the code actually meet its own requirements – namely, that it is correct. We then won't need tedious, full-of-holes QA process, once we have a mathematical proof that a code meets our requirements.</p>
                <p>But it turns out that life aren't so easy. The Halting problem over Turing machines became so famous not because its answer is “No”, but because its answer is both “Yes” and “No”! A contradiction. This situation is mildly called “undecidability”. And this can go arbitrarily far, any such contradiction can be elevated to any statement, supplying a proof that it is true, and also supplying a proof that it is false!</p>
                <p>Because of such pathologies, we can never trust a proof over a Turing complete language.  Completeness here happens to be precisely the completeness Godel spoke about, when he proved that any language that is expressive enough to describe arithmetic, must be either inconsistent or incomplete. Since Turing complete languages are also “Godel-complete”, they are provably inconsistent.</p>
                <p>Godel, therefore, left us with two paths completeness or consistency, while the latter implies decidability, the inability to prove an incorrect statement. Completeness is the ability to prove any correct theorem. Alas, if you can prove any correct theorem, then you can prove also any incorrect theorem!</p>
                <p>This is of course a very unpleasant situation for philosophers, logicians, mathematicians, and computer scientists. But a breaktrough came during the 70s and the 80s by Per Martin-Lof he presented the (now called) Martin-Lof Type Theory (MLTT). MLTT is a programming language with such an expressive power, that it is considered to replace the old foundations of mathematics that consist of first-order classical logic and ZFC set theory. This is as serious as it sounds, new foundations of mathematics. This is the mathematics of the 21st century.</p>
                <p>Why are those foundations “better”?</p>
                <p>1. They are in a language that fits computers too. We can now reformulate all math (a process that has already began, e.g. under the project of Homotopy Type Theory) in a way that a computer can comprehend, verify our proofs, and discover new proofs and theorems.</p>
                <p>2. This system is decidable. Although it picks Godel's consistency path, it turns out that the completeness it is giving up is not so painfulm it is only incomplete with respect to infinite codes. It cannot prove infinitely long mathematical claims or run code that assumes infinite computers (unlike Turing machines that are infinite by definition).</p>
                <p>MLTT covers all what matters finite computers and finite math formulas (infinite sets are welcome, even construction of the reals using Dedekind cuts – after all, this math gets into a finite book). As a result, given a syntactically well-formed code in MLTT together with a proof that “this code will halt” or “this code will never perform more than 1M operations”, we can trust the proof. The decidability guarantees that only true statements can be proved. Moreover, a machine can seek for a proof itself. This is called Automated Theorem Proving, but for complex enough problems their runtime is astronomically high. Yet, a “skeleton” of a complex proof can be supplied by human, letting the machine verifying it by trying to fill the missing parts of the proof.</p>
                <p>Back to our Blockchain construction, we can now put MLTT-compatible language on our blockchain, and we can now supply proofs for anything that we can prove, in a way that a 3rd party is able to trust our proofs. We need not to worry anymore about halting, or about security measures, or about correctness – we can simply require proofs for them all.</p>
                <p>On Tau we take RDF-family languages' syntax (notably Notation3 and Nquads, which consist of triples of “subject verb object”) and give them MLTT's semantics. Equipped with an automated theorem prover that JIT-compiles the proof search (or verification, as a special case), it offers a general-purpose programming language that is decidable, so code can provide proofs about itself (without even getting into self-reference paradoxes!). The language incorporates a Blockchain and DHT as mentioned several times in other locations. Thanks to MLTT and automatic reasoning, non-naive Tau is an intelligent, aware (at the sense it can reason over its own code), safe and trustless decentralized network, while remain so even when allowing general and arbitrary code to run.</p>
                <p>Of course, an explanation of what is Tau should come now and tell more about its features and uses, and we have discussed those in the past in various places (especially on this blog and on bitcointalk). So far on this post we concluded the Naive Tau construction, why it is doomed, and what is the correct way to perform secure multiparty computation.</p>

- title: "Proof of Code Execution"
  link: proof-of-code-execution
  id: 5
  order: 7
  author: Ohad Asor
  key: archive
  date: Sep 6, 2015
  content: Putting it altogether, code is rules and queries, while the compiler (being essentially an autoprover) follows the rules and their consequences and outputs answers (while performing any side-effects).
  main_content: <p>Putting it altogether, code is rules and queries, while the compiler (being essentially an autoprover) follows the rules and their consequences and outputs answers (while performing any side-effects). This is a closed loop, the code is retrieved from tau-chain upon a new block, using, obviously, some tau client. So we accept and execute block T by executing the code that appeared at block T-1, while block 0 is the genesis block.</p>
                <p>The code of the client should allow users run other tau code according to their preferences. It can be thought as the Appstore/Play application itself, while the network contain many other applications.</p>
                <p>Tau does not only provide a decentralized appstore, but delivers additional and essentially more powerful technologies. We mentioned several times the decidability of the code itself and its consequences. Now we'd like to discuss an independent feature which brings more power to tau applications (or the root chain itself).</p>
                <p>The autoprover is equipped with mechanism of hashing the proof search tree. The prover basically performs a breadth-first search that begins from the query and takes valid steps (according to the rules in the code), and tries to find facts along the search, and by this finishing a proof (a chain of valid moves from facts to the query).</p>
                <p>This tree can be hashed like a Merkle tree. Eventually, the hash of the tree's root is a proof that the whole computation was followed, since one can replay the computation and verify the hash. There are much more efficient methods than replaying the whole tree, as in lambda-auth which presents the algorithm we intend to implement.</p>
                <p>By that, one can prove and verify a local execution of code. Exogenic information (like IO) is treated as Monads, IO is a monad and is not an Auth type. For more information about monads please refer to functional programming literature, but note that this weakness of IO isn't always a trouble, when a user A knows they're connecting to server B, they can trust B's proof of flow that originates from the requests A initiated locally.</p>
                <p>How this can elevate crowd computing, and the performance issues arising at this scope, will be a discussion from some other time. Let's mention some more specific applications for now. One example would be an exchange. The exchange can reveal its own code, and constantly provide proofs that that very code was executed. Another example would be a casino, proving that the whole game indeed followed the rules, including, say, a certain hash computation for random number generation. Also, serving as a DHT or even vanilla Bitcoin client can be proved.</p>
                <p>A derived feature is the ability to verify participation on the network itself, one can prove that they ran a tau client, and designers of voting schemes may rely on this ability. It is also possible to automatically award coins given a proof of execution (over say Agoras, but not over non-tau coins like BTC), just like it is possible to set any rules to any proof.</p>
                <p>I guess that would be enough to ignite the imagination. The 21st advancements of decentralization, cryptography, provability and verifiable computing, open frontiers to a new kind of networking abilities and experience.</p>

- title: Decentralized Democracy and the Role of the First Users
  link: decentralized-democracy-and-the-role-of-the-first-users
  author: Ohad Asor
  id: 6
  order: 0 
  key: archive
  date: Sep 1, 2015
  content: Recently we mentioned several times the logical and technological properties of tau, and now maybe it is time to take a step back and look at the broader picture. We mentioned that tau's programming language is actually rules and logic. 
  main_content: <p>Recently we mentioned several times the logical and technological properties of tau, and now maybe it is time to take a step back and look at the broader picture. We mentioned that tau's programming language is actually rules and logic. We meet rules and logic in many other aspects of life, a relatively small example is that the pure logic structure in solutions to existing problems can be used automatically to cope with unsolved problems, even in an entirely non-related field, like some Chemical structure being isomorphic to some existing computer program.</p>
                <p>This is still a certain use case and is aside the main point, and the main point is decentralized democracy.</p>
                <p>Tau is able to formalize laws, query their consequences, and verify their consistency. It is able to do so in a fully decentralized mode. Tau cannot directly interact with the laws of reality, but it defines its own rules. The network is self-definable and self-amendable. The software client is a compiler that downloads source code from the blockchain and executes that code. The code may (and should occasionally) vary from block to block. Essentially, the most important part of the client's code is the conditions for accepting the next block.</p>
                <p>The rules, protocol, and specific behavior of the network are of course a main factor in the evolution of the network. But specifying them is not our first task upon genesis. Our first task is to specify how rules can be changed, somehow disregarding what those rules actually are.</p>
                <p>Tau's logic and infrastructure allow separation of Contexts. By Context we mean a set of rules that applies only to participants that actively wish to subscribe to that context. The terminology comes from the RDF world, tau's language is formed by quadruples of subject-verb-object-context, so the fact or rule described in "subject-verb-object" applies only at the given context. Nevertheless, code reuse across contexts is possible, and is commonly denoted as context1:subject context2:predicate etc. Contexts can also be pegged on the root chain as sidechains can be pegged on Bitcoin's chain.</p>
                <p>On every context, one may have any kind of custom rules. So the root chain should not intervene on what happens in custom contexts, but define only the rules vital for its own existence. Tau can be bootstrapped with simple arbitrary rules, even roster of first participants, or centralized insertion of code by us. Whatever those rules will be, they are temporary, and our first task is to define how and when rules can be changed at all. Afterwards, we follow the process of rule-making we formalized at the first step, and define together the rules themselves. We, tau's developers, will be highly active at those post-genesis processes, but we will not hold any extra power. Each one of us will begin at genesis as equal exactly like any one else. </p>
                <p>We put a technology for decentralized democracy on the table, that can scale from democracy over a small club in the form of Context tau, into, who knows, maybe even state laws. I see no technological barrier for that. Nevertheless, we also do not have any magical ultimate set of rules.</p>
                <p>The task is hard, and the philosophical questions are overwhelming. But there is a limit to what technology can do. It can give us a platform for decentralized democracy, but it cannot set the rules for us. I cannot exaggerate about the importance of the task of bootstrapping a decentralized democracy and forming its "constitution", therefore I won't, and will only mention that I guess that many readers share the same feeling with me - that we probably can do at least slightly better than our current situation.</p>
                <p>Obviously, the last thing we can do as developers of a democratic system is to set its rules ourselves.</p>
                <p>Formalizing a real-life decentralized democracy is not the first users' duty, of course. It is a much larger-scale process. The first users will need to define how to change the rules of the root chain - not even deal with the technical details like the maximum block size, but what happens if we want to change the block size, namely what are the conditions for a root-chain's rule change. It is an interesting litmus test as for itself. How would the rules of changing the rules evolve given our new logical and decentralization abilities, one can only barely imagine. Let's all hope that tau will actually evolve into collaboration of morals, not only economics, code and knowledge.</p>
                


